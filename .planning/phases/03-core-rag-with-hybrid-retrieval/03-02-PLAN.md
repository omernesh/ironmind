---
phase: 03-core-rag-with-hybrid-retrieval
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/services/retriever.py
  - backend/app/services/indexer.py
autonomous: true

must_haves:
  truths:
    - "Hybrid search combines semantic embeddings and BM25 keyword search"
    - "Results are fused using Reciprocal Rank Fusion (RRF)"
    - "Search filters by user_id for multi-tenant isolation"
    - "Retrieval returns chunks with metadata (doc_id, filename, page_range, section_title)"
    - "Low-scoring chunks below threshold are filtered out"
  artifacts:
    - path: "backend/app/services/retriever.py"
      provides: "Hybrid retrieval service"
      exports: ["HybridRetriever"]
      min_lines: 80
    - path: "backend/app/services/indexer.py"
      provides: "Updated indexer with hybrid search support"
      contains: "hybrid"
  key_links:
    - from: "backend/app/services/retriever.py"
      to: "backend/app/services/indexer.py"
      via: "TxtaiIndexer.hybrid_search"
      pattern: "hybrid_search"
    - from: "backend/app/services/retriever.py"
      to: "backend/app/config.py"
      via: "settings import"
      pattern: "from app.config import settings"
---

<objective>
Implement hybrid retrieval service with BM25 + semantic fusion.

Purpose: Enable dual-channel search (semantic similarity + keyword matching) for technical documents where exact terms matter.
Output: HybridRetriever service and updated TxtaiIndexer with hybrid search capability
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-core-rag-with-hybrid-retrieval/03-RESEARCH.md
@.planning/phases/03-core-rag-with-hybrid-retrieval/03-CONTEXT.md
@.planning/phases/03-core-rag-with-hybrid-retrieval/03-01-SUMMARY.md
@backend/app/services/indexer.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update TxtaiIndexer for hybrid search</name>
  <files>backend/app/services/indexer.py</files>
  <action>
Update backend/app/services/indexer.py to enable hybrid search:

**Modify _initialize_embeddings() config:**
```python
config = {
    "path": settings.OPENAI_EMBEDDING_MODEL,  # Use OpenAI embeddings
    "content": True,
    "backend": "sqlite",
    "hybrid": True,  # Enable hybrid search
    "scoring": {
        "method": "bm25",
        "normalize": True  # Required for RRF fusion
    }
}
```

**Add hybrid_search method:**
```python
def hybrid_search(
    self,
    query: str,
    user_id: str,
    limit: int = 25,
    weights: float = 0.5,  # 0.5 = equal semantic/BM25
    threshold: float = 0.3
) -> List[Dict[str, Any]]:
    """
    Hybrid search combining semantic and BM25 with user filtering.

    Args:
        query: Search query
        user_id: User ID for filtering
        limit: Max results
        weights: Semantic/BM25 balance (0=BM25 only, 1=semantic only)
        threshold: Minimum score to include

    Returns:
        List of chunks with scores and metadata
    """
```

The method should:
1. Use txtai's hybrid search with weights parameter
2. Filter results by user_id
3. Filter results below threshold
4. Return full metadata (doc_id, filename, page_range, section_title, text)
5. Include both semantic_score and bm25_score in results for diagnostics

**Handle OpenAI embedding API:**
txtai with path="text-embedding-3-small" requires OpenAI API key in environment.
Add fallback logic: if OPENAI_API_KEY not set, use sentence-transformers fallback with warning log.
  </action>
  <verify>
python -c "from app.services.indexer import TxtaiIndexer; idx = TxtaiIndexer(); print('Indexer initialized with hybrid:', hasattr(idx, 'hybrid_search'))"
  </verify>
  <done>
TxtaiIndexer has hybrid_search method that combines semantic + BM25 with user filtering
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HybridRetriever service</name>
  <files>backend/app/services/retriever.py, backend/app/services/__init__.py</files>
  <action>
Create backend/app/services/retriever.py with HybridRetriever class:

```python
"""Hybrid retrieval service for RAG pipeline."""
import time
from typing import List, Dict, Any, Optional
from app.services.indexer import TxtaiIndexer
from app.config import settings
from app.core.logging import get_logger

logger = get_logger()


class HybridRetriever:
    """
    Hybrid retrieval combining semantic and BM25 search.

    Uses txtai's built-in hybrid search with RRF fusion.
    Filters by user_id for multi-tenant isolation.
    """

    def __init__(self, indexer: Optional[TxtaiIndexer] = None):
        self.indexer = indexer or TxtaiIndexer()

    async def retrieve(
        self,
        query: str,
        user_id: str,
        request_id: str,
        limit: int = None,
        weights: float = None,
        threshold: float = None
    ) -> Dict[str, Any]:
        """
        Retrieve relevant chunks using hybrid search.

        Args:
            query: User's question
            user_id: User ID for filtering
            request_id: Request correlation ID
            limit: Override default retrieval limit
            weights: Override default hybrid weights
            threshold: Override default relevance threshold

        Returns:
            {
                "chunks": List of chunk dicts with metadata,
                "count": Number of chunks returned,
                "latency_ms": Retrieval time in ms,
                "diagnostics": {scores, ranks, etc.}
            }
        """
```

The retrieve method should:
1. Start timing
2. Call indexer.hybrid_search() with parameters
3. Log retrieval diagnostics (count, scores, latency)
4. Return structured result with chunks and metadata

Add preprocess_query helper:
- Expand common aerospace acronyms (UAV, IMU, GPS, etc.)
- Strip extra whitespace
- Return expanded query for better semantic matching

Update backend/app/services/__init__.py to export HybridRetriever.
  </action>
  <verify>
python -c "from app.services.retriever import HybridRetriever; print('HybridRetriever loaded')"
  </verify>
  <done>
HybridRetriever.retrieve() returns chunks with metadata and diagnostics
  </done>
</task>

</tasks>

<verification>
1. TxtaiIndexer initializes with hybrid=True: Check config in indexer.py
2. hybrid_search method exists and filters by user_id
3. HybridRetriever imports and initializes without error
4. Retriever logs diagnostic information (mock test with empty index)
</verification>

<success_criteria>
- TxtaiIndexer._initialize_embeddings() sets hybrid=True and scoring.normalize=True
- TxtaiIndexer.hybrid_search() accepts query, user_id, limit, weights, threshold
- HybridRetriever.retrieve() returns dict with chunks, count, latency_ms, diagnostics
- User_id filtering applied at retrieval level (not post-filter)
- Threshold filtering removes low-score chunks
- Diagnostic logging includes scores, count, latency
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-rag-with-hybrid-retrieval/03-02-SUMMARY.md`
</output>
