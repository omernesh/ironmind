---
phase: 05-multi-source-synthesis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/graph/schemas.py
  - backend/app/services/graph/doc_relationships.py
  - backend/app/models/chat.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "DocumentRelationship schema validates source/target doc IDs and relationship types"
    - "DocRelationshipStore can add document nodes and relationships to FalkorDB"
    - "Citation model includes multi_source field for multi-document claims"
  artifacts:
    - path: "backend/app/services/graph/doc_relationships.py"
      provides: "Document relationship graph storage"
      exports: ["DocumentRelationshipStore"]
      min_lines: 100
    - path: "backend/app/services/graph/schemas.py"
      provides: "DocumentRelationship Pydantic schema"
      contains: "class DocumentRelationship"
    - path: "backend/app/models/chat.py"
      provides: "Extended Citation with multi_source field"
      contains: "multi_source"
  key_links:
    - from: "backend/app/services/graph/doc_relationships.py"
      to: "backend/app/services/graph/graph_store.py"
      via: "reuses FalkorDB connection pattern"
      pattern: "self\\.graph\\.query"
---

<objective>
Create foundational schemas and storage layer for document relationship graph.

Purpose: Enable tracking which documents reference which other documents (explicit citations + shared entities) to improve multi-document synthesis.
Output: DocumentRelationship schema, DocRelationshipStore class, extended Citation model.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-source-synthesis/05-CONTEXT.md
@.planning/phases/05-multi-source-synthesis/05-RESEARCH.md
@backend/app/services/graph/schemas.py
@backend/app/services/graph/graph_store.py
@backend/app/models/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DocumentRelationship schema to graph schemas</name>
  <files>backend/app/services/graph/schemas.py</files>
  <action>
Add DocumentRelationship Pydantic model to the existing schemas.py file:

```python
class DocumentRelationship(BaseModel):
    """Relationship between two documents in the corpus.

    Attributes:
        source_doc_id: Document that contains the reference
        target_doc_id: Document being referenced
        relationship_type: Type of cross-reference:
            - explicit_citation: Direct reference ("See Document X", doc codes, hyperlinks)
            - shared_entities: Documents share 2+ common entities
        strength: Confidence score (0.0-1.0). Explicit citations = 1.0, shared entities = 0.5-0.9
        evidence: List of citation text or shared entity names supporting this relationship
    """
    source_doc_id: str = Field(..., description="Document containing the reference")
    target_doc_id: str = Field(..., description="Document being referenced")
    relationship_type: Literal["explicit_citation", "shared_entities"] = Field(
        ..., description="Type of cross-reference"
    )
    strength: float = Field(..., ge=0.0, le=1.0, description="Confidence score")
    evidence: List[str] = Field(default_factory=list, description="Supporting evidence")
```

Import List from typing if not already imported.
  </action>
  <verify>python -c "from backend.app.services.graph.schemas import DocumentRelationship; print('Schema OK')"</verify>
  <done>DocumentRelationship schema exists with source_doc_id, target_doc_id, relationship_type (Literal), strength, and evidence fields</done>
</task>

<task type="auto">
  <name>Task 2: Create DocumentRelationshipStore for FalkorDB storage</name>
  <files>backend/app/services/graph/doc_relationships.py</files>
  <action>
Create new file doc_relationships.py with DocumentRelationshipStore class. Follow patterns from graph_store.py:

```python
"""Document relationship graph storage in FalkorDB.

Manages document-level relationships for multi-source synthesis:
- CITES edges for explicit citations between documents
- SHARES_ENTITIES edges for documents with 2+ common entities
"""
from typing import List, Dict, Any, Optional
import structlog
from falkordb import FalkorDB

from app.config import settings
from .schemas import DocumentRelationship

logger = structlog.get_logger(__name__)


class DocumentRelationshipStore:
    """Manages document-level relationship graph in FalkorDB.

    Schema:
    - Nodes: Document (doc_id, filename, user_id, page_count, chunk_count)
    - Edges: CITES (explicit), SHARES_ENTITIES (implicit)
    """

    def __init__(self):
        """Initialize FalkorDB connection (reuses same DB as entity graph)."""
        try:
            url_parts = settings.FALKORDB_URL.replace("redis://", "").split(":")
            host = url_parts[0]
            port = int(url_parts[1]) if len(url_parts) > 1 else 6379

            self.db = FalkorDB(host=host, port=port)
            self.graph = self.db.select_graph(settings.FALKORDB_GRAPH_NAME)

            logger.info("doc_relationship_store_connected", host=host, port=port)
            self.ensure_indexes()

        except Exception as e:
            logger.error("doc_relationship_store_connection_failed", error=str(e))
            raise

    def ensure_indexes(self) -> None:
        """Create indexes on Document node properties."""
        indexes = [
            "CREATE INDEX ON :Document(doc_id)",
            "CREATE INDEX ON :Document(user_id)",
        ]
        for query in indexes:
            try:
                self.graph.query(query)
            except Exception as e:
                if "already indexed" not in str(e).lower():
                    logger.warning("doc_index_warning", query=query, error=str(e))

    def add_document_node(
        self,
        doc_id: str,
        filename: str,
        user_id: str,
        page_count: int = 0,
        chunk_count: int = 0
    ) -> bool:
        """Add or update document node in relationship graph."""
        try:
            query = """
            MERGE (d:Document {doc_id: $doc_id, user_id: $user_id})
            SET d.filename = $filename,
                d.page_count = $page_count,
                d.chunk_count = $chunk_count
            RETURN d
            """
            params = {
                "doc_id": doc_id,
                "user_id": user_id,
                "filename": filename,
                "page_count": page_count,
                "chunk_count": chunk_count
            }
            self.graph.query(query, params=params)
            logger.debug("document_node_added", doc_id=doc_id, filename=filename)
            return True
        except Exception as e:
            logger.error("add_document_node_failed", doc_id=doc_id, error=str(e))
            return False

    def add_relationship(self, rel: DocumentRelationship, user_id: str) -> bool:
        """Add relationship between documents."""
        try:
            edge_type = "CITES" if rel.relationship_type == "explicit_citation" else "SHARES_ENTITIES"

            query = f"""
            MATCH (source:Document {{doc_id: $source_id, user_id: $user_id}})
            MATCH (target:Document {{doc_id: $target_id, user_id: $user_id}})
            MERGE (source)-[r:{edge_type}]->(target)
            SET r.strength = $strength,
                r.evidence = $evidence
            RETURN r
            """
            params = {
                "source_id": rel.source_doc_id,
                "target_id": rel.target_doc_id,
                "user_id": user_id,
                "strength": rel.strength,
                "evidence": rel.evidence
            }
            result = self.graph.query(query, params=params)

            if result.result_set:
                logger.debug("doc_relationship_added",
                           source=rel.source_doc_id,
                           target=rel.target_doc_id,
                           type=rel.relationship_type)
                return True
            return False
        except Exception as e:
            logger.error("add_doc_relationship_failed", error=str(e))
            return False

    def get_related_documents(
        self,
        doc_ids: List[str],
        user_id: str,
        min_strength: float = 0.5
    ) -> List[Dict[str, Any]]:
        """Get documents related to input set (for multi-doc queries)."""
        try:
            query = """
            UNWIND $doc_ids AS source_doc_id
            MATCH (source:Document {doc_id: source_doc_id, user_id: $user_id})
            MATCH (source)-[r]-(related:Document)
            WHERE r.strength >= $min_strength AND related.user_id = $user_id
            RETURN DISTINCT related.doc_id as doc_id,
                   related.filename as filename,
                   r.strength as strength,
                   type(r) as relationship_type
            ORDER BY r.strength DESC
            """
            params = {
                "doc_ids": doc_ids,
                "user_id": user_id,
                "min_strength": min_strength
            }
            result = self.graph.query(query, params=params)

            return [
                {
                    "doc_id": row[0],
                    "filename": row[1],
                    "strength": row[2],
                    "relationship_type": row[3]
                }
                for row in result.result_set
            ]
        except Exception as e:
            logger.error("get_related_documents_failed", error=str(e))
            return []

    def get_all_relationships(self, user_id: str) -> List[Dict[str, Any]]:
        """Get all document relationships for a user (for debug endpoint)."""
        try:
            query = """
            MATCH (source:Document {user_id: $user_id})-[r]->(target:Document)
            RETURN source.doc_id as source_doc_id,
                   source.filename as source_filename,
                   target.doc_id as target_doc_id,
                   target.filename as target_filename,
                   type(r) as relationship_type,
                   r.strength as strength,
                   r.evidence as evidence
            """
            params = {"user_id": user_id}
            result = self.graph.query(query, params=params)

            return [
                {
                    "source_doc_id": row[0],
                    "source_filename": row[1],
                    "target_doc_id": row[2],
                    "target_filename": row[3],
                    "relationship_type": row[4],
                    "strength": row[5],
                    "evidence": row[6]
                }
                for row in result.result_set
            ]
        except Exception as e:
            logger.error("get_all_relationships_failed", error=str(e))
            return []

    def delete_document_relationships(self, doc_id: str, user_id: str) -> int:
        """Delete document node and all its relationships (for re-ingestion)."""
        try:
            query = """
            MATCH (d:Document {doc_id: $doc_id, user_id: $user_id})
            DETACH DELETE d
            RETURN count(d) as deleted
            """
            params = {"doc_id": doc_id, "user_id": user_id}
            result = self.graph.query(query, params=params)

            deleted = result.result_set[0][0] if result.result_set else 0
            logger.info("document_relationships_deleted", doc_id=doc_id, deleted=deleted)
            return deleted
        except Exception as e:
            logger.error("delete_document_relationships_failed", error=str(e))
            return 0

    def count_relationships(self, user_id: str) -> Dict[str, int]:
        """Count document relationships by type."""
        try:
            query = """
            MATCH (a:Document {user_id: $user_id})-[r]->(b:Document)
            RETURN type(r) as rel_type, count(r) as count
            """
            params = {"user_id": user_id}
            result = self.graph.query(query, params=params)

            counts = {"cites": 0, "shares_entities": 0}
            for row in result.result_set:
                rel_type = row[0].lower()
                counts[rel_type] = row[1]
            return counts
        except Exception as e:
            logger.error("count_doc_relationships_failed", error=str(e))
            return {"cites": 0, "shares_entities": 0}
```

Also update backend/app/services/graph/__init__.py to export DocumentRelationshipStore:
```python
from .doc_relationships import DocumentRelationshipStore
```
  </action>
  <verify>python -c "from backend.app.services.graph import DocumentRelationshipStore; print('Store OK')"</verify>
  <done>DocumentRelationshipStore class exists with add_document_node, add_relationship, get_related_documents, get_all_relationships methods</done>
</task>

<task type="auto">
  <name>Task 3: Extend Citation model with multi-source fields</name>
  <files>backend/app/models/chat.py, backend/requirements.txt</files>
  <action>
Update Citation model in chat.py to add multi-source synthesis fields:

```python
class Citation(BaseModel):
    """Citation linking answer to source document chunk."""

    id: int = Field(..., description="Footnote number [1], [2], etc.")
    doc_id: str = Field(..., description="Document UUID")
    filename: str = Field(..., description="Original filename")
    page_range: str = Field(..., description="Page range (e.g., '42-43')")
    section_title: Optional[str] = Field(None, description="Section heading if available")
    snippet: str = Field(..., description="First 200 chars of chunk text")
    score: Optional[float] = Field(None, description="Reranker score for diagnostics")
    source: str = Field(default="document", description="Source type: 'document' or 'graph'")

    # Multi-source synthesis fields (Phase 5)
    multi_source: bool = Field(
        default=False,
        description="True if part of multi-source claim with adjacent citations"
    )
    related_doc_ids: Optional[List[str]] = Field(
        None,
        description="Related document IDs if document relationships exist"
    )
```

Also update ChatResponse to include synthesis metadata:
```python
class ChatResponse(BaseModel):
    """RAG pipeline response with answer and citations."""

    answer: str = Field(..., description="Generated answer text")
    citations: List[Citation] = Field(default_factory=list, description="Source citations")
    request_id: str = Field(..., description="Unique request identifier for tracing")
    diagnostics: Optional[DiagnosticInfo] = Field(None, description="Performance metrics (debug mode only)")

    # Multi-source synthesis metadata (Phase 5)
    synthesis_mode: bool = Field(default=False, description="True if multi-document synthesis was used")
    source_doc_count: int = Field(default=1, description="Number of distinct source documents")
```

Add to requirements.txt if not present:
```
python-Levenshtein>=0.25.0
networkx>=3.0
```
  </action>
  <verify>python -c "from backend.app.models.chat import Citation, ChatResponse; c = Citation(id=1, doc_id='a', filename='b', page_range='1', snippet='test', multi_source=True); print('Citation OK')"</verify>
  <done>Citation model has multi_source and related_doc_ids fields; ChatResponse has synthesis_mode and source_doc_count fields</done>
</task>

</tasks>

<verification>
1. All imports work: `python -c "from backend.app.services.graph import DocumentRelationshipStore; from backend.app.services.graph.schemas import DocumentRelationship"`
2. Citation model validates: `python -c "from backend.app.models.chat import Citation; c = Citation(id=1, doc_id='d', filename='f', page_range='1-2', snippet='text', multi_source=True); print(c.multi_source)"`
3. DocumentRelationship schema validates: `python -c "from backend.app.services.graph.schemas import DocumentRelationship; r = DocumentRelationship(source_doc_id='a', target_doc_id='b', relationship_type='explicit_citation', strength=1.0); print(r.relationship_type)"`
</verification>

<success_criteria>
- DocumentRelationship Pydantic schema exists with Literal relationship_type constraint
- DocumentRelationshipStore class provides CRUD for document relationships in FalkorDB
- Citation model includes multi_source boolean field
- ChatResponse model includes synthesis_mode and source_doc_count fields
- New dependencies (python-Levenshtein, networkx) added to requirements.txt
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-source-synthesis/05-01-SUMMARY.md`
</output>
