---
phase: 05-multi-source-synthesis
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - backend/app/services/retriever.py
  - backend/app/routers/debug.py
  - backend/tests/test_multi_source.py
autonomous: true

must_haves:
  truths:
    - "Retriever expands results using document relationship graph for related docs"
    - "Debug endpoint /api/debug/doc-relationships returns document relationship graph"
    - "Multi-document queries return citations from 3+ sources when available"
    - "End-to-end: upload 2+ docs -> chat query -> synthesis answer with multi-source citations"
  artifacts:
    - path: "backend/app/services/retriever.py"
      provides: "Document relationship-aware retrieval"
      contains: "doc_rel_store"
    - path: "backend/app/routers/debug.py"
      provides: "Document relationship debug endpoint"
      contains: "doc-relationships"
    - path: "backend/tests/test_multi_source.py"
      provides: "Integration tests for multi-source synthesis"
      min_lines: 50
  key_links:
    - from: "backend/app/services/retriever.py"
      to: "backend/app/services/graph/doc_relationships.py"
      via: "expands retrieval with related documents"
      pattern: "get_related_documents"
    - from: "backend/app/routers/debug.py"
      to: "backend/app/services/graph/doc_relationships.py"
      via: "returns all relationships for debug"
      pattern: "get_all_relationships"
---

<objective>
Integrate document relationships into retrieval and add debug endpoint with verification.

Purpose: Complete Phase 5 by wiring document relationship graph into retrieval (expand results to include related docs), adding debug endpoint for inspection, and verifying end-to-end multi-source synthesis.
Output: Enhanced retriever, debug endpoint, integration tests.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-source-synthesis/05-CONTEXT.md
@.planning/phases/05-multi-source-synthesis/05-RESEARCH.md
@.planning/phases/05-multi-source-synthesis/05-01-SUMMARY.md
@.planning/phases/05-multi-source-synthesis/05-02-SUMMARY.md
@.planning/phases/05-multi-source-synthesis/05-03-SUMMARY.md
@backend/app/services/retriever.py
@backend/app/routers/debug.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance retriever with document relationship expansion</name>
  <files>backend/app/services/retriever.py</files>
  <action>
Update HybridRetriever to expand retrieval results using document relationship graph.

Add import at top:
```python
from app.services.graph.doc_relationships import DocumentRelationshipStore
```

Update __init__ to initialize doc relationship store:
```python
def __init__(
    self,
    indexer: Optional[TxtaiIndexer] = None,
    graph_retriever: Optional[GraphRetriever] = None,
    doc_rel_store: Optional[DocumentRelationshipStore] = None
):
    self.indexer = indexer or TxtaiIndexer()
    self.graph_retriever = graph_retriever or GraphRetriever()
    self.doc_rel_store = doc_rel_store or DocumentRelationshipStore()
```

Add method to expand retrieval using document relationships:

```python
def _expand_with_related_docs(
    self,
    chunks: List[Dict[str, Any]],
    user_id: str,
    limit: int
) -> List[Dict[str, Any]]:
    """
    Expand retrieval results by fetching chunks from related documents.

    When we have chunks from doc A, and doc A CITES or SHARES_ENTITIES with doc B,
    fetch additional chunks from doc B to enable multi-document synthesis.
    """
    if not chunks:
        return chunks

    # Get unique doc_ids from current results
    current_doc_ids = list(set(c.get('doc_id') for c in chunks if c.get('doc_id')))

    if not current_doc_ids:
        return chunks

    try:
        # Find related documents
        related_docs = self.doc_rel_store.get_related_documents(
            doc_ids=current_doc_ids,
            user_id=user_id,
            min_strength=0.5  # Include both explicit citations and shared entities
        )

        if not related_docs:
            return chunks

        # Get additional chunks from related documents
        # Prioritize by relationship strength
        related_doc_ids = [
            d['doc_id'] for d in related_docs
            if d['doc_id'] not in current_doc_ids
        ][:3]  # Limit to top 3 related docs

        if not related_doc_ids:
            return chunks

        # Fetch top chunks from related documents using existing search
        # (reuse query from original search to maintain relevance)
        # This requires passing query to this method or storing it

        logger.info(
            "doc_relationship_expansion",
            original_doc_count=len(current_doc_ids),
            related_doc_count=len(related_doc_ids),
            user_id=user_id
        )

        return chunks  # For now, just log - full implementation below

    except Exception as e:
        logger.warning("doc_relationship_expansion_failed", error=str(e))
        return chunks
```

Update the retrieve method to use document relationship expansion. Add this after the merge_channels call but before returning:

```python
# Expand with related documents (for multi-source synthesis)
doc_expansion_enabled = getattr(settings, 'DOC_RELATIONSHIP_EXPANSION_ENABLED', True)
if doc_expansion_enabled and len(merged_chunks) > 0:
    try:
        # Get doc IDs from current results
        current_doc_ids = list(set(
            c.get('doc_id') for c in merged_chunks
            if c.get('doc_id') and c.get('source') != 'graph'
        ))

        if len(current_doc_ids) >= 1:
            # Find related documents
            related_docs = self.doc_rel_store.get_related_documents(
                doc_ids=current_doc_ids,
                user_id=user_id,
                min_strength=0.5
            )

            # Get IDs of docs not already in results
            new_doc_ids = [
                d['doc_id'] for d in related_docs
                if d['doc_id'] not in current_doc_ids
            ][:2]  # Limit expansion to 2 related docs

            if new_doc_ids:
                # Fetch chunks from related docs
                for related_doc_id in new_doc_ids:
                    related_chunks = self.indexer.hybrid_search(
                        query=expanded_query,
                        user_id=user_id,
                        limit=3,  # Fewer chunks per related doc
                        weights=weights,
                        threshold=threshold,
                        doc_id_filter=related_doc_id  # Filter to specific doc
                    )

                    # Add if not already present
                    for chunk in related_chunks[:2]:
                        if chunk not in merged_chunks:
                            # Mark as expanded
                            chunk['expanded_from_relationship'] = True
                            merged_chunks.append(chunk)

                logger.info(
                    "doc_relationship_expansion_complete",
                    request_id=request_id,
                    original_docs=len(current_doc_ids),
                    expanded_docs=len(new_doc_ids),
                    total_chunks=len(merged_chunks)
                )

    except Exception as e:
        logger.warning("doc_relationship_expansion_failed",
                      request_id=request_id,
                      error=str(e))
```

NOTE: The indexer.hybrid_search may need doc_id_filter parameter added. If not present, add to indexer.py:
```python
def hybrid_search(
    self,
    query: str,
    user_id: str,
    limit: int = 25,
    weights: float = 0.5,
    threshold: float = 0.3,
    doc_id_filter: Optional[str] = None  # NEW parameter
) -> List[Dict[str, Any]]:
    # In the filter expression, add doc_id check if provided:
    # filter_expr = f"user_id = '{user_id}'"
    # if doc_id_filter:
    #     filter_expr += f" AND doc_id = '{doc_id_filter}'"
```
  </action>
  <verify>python -c "from backend.app.services.retriever import HybridRetriever; r = HybridRetriever(); print(hasattr(r, 'doc_rel_store'))"`</verify>
  <done>HybridRetriever expands results using document relationship graph, fetching chunks from related documents</done>
</task>

<task type="auto">
  <name>Task 2: Add document relationship debug endpoint</name>
  <files>backend/app/routers/debug.py</files>
  <action>
Add debug endpoint for document relationship inspection to existing debug.py router.

Add import:
```python
from app.services.graph.doc_relationships import DocumentRelationshipStore
```

Add endpoint:
```python
@router.get("/doc-relationships")
async def get_document_relationships(
    user_id: str = Depends(get_current_user_id),
    doc_id: Optional[str] = Query(None, description="Filter by specific document"),
    format: str = Query("edgelist", description="Output format: edgelist or cytoscape")
):
    """
    Debug endpoint: Inspect document relationship graph.

    Returns relationships between documents (CITES, SHARES_ENTITIES).

    Formats:
    - edgelist: Simple JSON list of relationships
    - cytoscape: Format for Cytoscape.js visualization
    """
    doc_rel_store = DocumentRelationshipStore()

    if doc_id:
        # Get relationships for specific document
        relationships = doc_rel_store.get_related_documents(
            doc_ids=[doc_id],
            user_id=user_id,
            min_strength=0.0  # Include all for debugging
        )
    else:
        # Get all relationships for user
        relationships = doc_rel_store.get_all_relationships(user_id)

    if format == "cytoscape":
        return _format_for_cytoscape(relationships)
    else:
        return {
            "user_id": user_id,
            "relationship_count": len(relationships),
            "relationships": relationships,
            "format": "edgelist"
        }


@router.get("/doc-relationships/stats")
async def get_document_relationship_stats(
    user_id: str = Depends(get_current_user_id)
):
    """
    Debug endpoint: Get document relationship statistics.

    Returns counts of CITES and SHARES_ENTITIES relationships.
    """
    doc_rel_store = DocumentRelationshipStore()
    counts = doc_rel_store.count_relationships(user_id)

    return {
        "user_id": user_id,
        "relationship_counts": counts,
        "total": sum(counts.values())
    }


def _format_for_cytoscape(relationships: List[Dict]) -> Dict:
    """Format relationships for Cytoscape.js visualization."""
    nodes = {}
    edges = []

    for rel in relationships:
        source_id = rel.get('source_doc_id', '')
        target_id = rel.get('target_doc_id', '')

        # Add source node
        if source_id and source_id not in nodes:
            nodes[source_id] = {
                "data": {
                    "id": source_id,
                    "label": rel.get('source_filename', source_id[:8])
                }
            }

        # Add target node
        if target_id and target_id not in nodes:
            nodes[target_id] = {
                "data": {
                    "id": target_id,
                    "label": rel.get('target_filename', target_id[:8])
                }
            }

        # Add edge
        edges.append({
            "data": {
                "source": source_id,
                "target": target_id,
                "label": rel.get('relationship_type', 'related'),
                "strength": rel.get('strength', 0.5)
            }
        })

    return {
        "nodes": list(nodes.values()),
        "edges": edges
    }
```

Add Optional import if not present:
```python
from typing import Optional, List, Dict
from fastapi import Query
```
  </action>
  <verify>curl -s http://localhost:8000/api/debug/doc-relationships/stats -H "Authorization: Bearer test" || echo "Endpoint added (requires running server to test)"</verify>
  <done>Debug endpoints /api/debug/doc-relationships and /api/debug/doc-relationships/stats exist</done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for multi-source synthesis</name>
  <files>backend/tests/test_multi_source.py</files>
  <action>
Create integration tests for Phase 5 multi-source synthesis functionality:

```python
"""Integration tests for multi-source synthesis (Phase 5).

Tests cross-reference detection, document relationship storage,
and multi-document synthesis generation.
"""
import pytest
from unittest.mock import MagicMock, patch, AsyncMock

from app.services.graph.schemas import DocumentRelationship
from app.services.graph.doc_relationships import DocumentRelationshipStore
from app.services.graph.cross_reference import CrossReferenceDetector
from app.services.generator import (
    Generator,
    should_activate_synthesis_mode,
    build_synthesis_context
)
from app.models.chat import Citation, ChatResponse


class TestDocumentRelationshipSchema:
    """Tests for DocumentRelationship Pydantic schema."""

    def test_explicit_citation_schema(self):
        """Test explicit citation relationship validation."""
        rel = DocumentRelationship(
            source_doc_id="doc-001",
            target_doc_id="doc-002",
            relationship_type="explicit_citation",
            strength=1.0,
            evidence=["See FC-001 specification"]
        )
        assert rel.relationship_type == "explicit_citation"
        assert rel.strength == 1.0

    def test_shared_entities_schema(self):
        """Test shared entities relationship validation."""
        rel = DocumentRelationship(
            source_doc_id="doc-001",
            target_doc_id="doc-003",
            relationship_type="shared_entities",
            strength=0.7,
            evidence=["GPS Module", "Navigation System"]
        )
        assert rel.relationship_type == "shared_entities"
        assert len(rel.evidence) == 2

    def test_invalid_relationship_type_rejected(self):
        """Test that invalid relationship types are rejected."""
        with pytest.raises(ValueError):
            DocumentRelationship(
                source_doc_id="doc-001",
                target_doc_id="doc-002",
                relationship_type="invalid_type",
                strength=0.5
            )

    def test_strength_bounds(self):
        """Test strength must be between 0 and 1."""
        with pytest.raises(ValueError):
            DocumentRelationship(
                source_doc_id="doc-001",
                target_doc_id="doc-002",
                relationship_type="explicit_citation",
                strength=1.5  # Invalid: > 1.0
            )


class TestSynthesisModeDetection:
    """Tests for synthesis mode activation logic."""

    def test_single_document_no_synthesis(self):
        """Single document should not trigger synthesis mode."""
        chunks = [
            {"doc_id": "doc-001", "text": "chunk 1"},
            {"doc_id": "doc-001", "text": "chunk 2"},
            {"doc_id": "doc-001", "text": "chunk 3"},
        ]
        assert should_activate_synthesis_mode(chunks) is False

    def test_two_documents_triggers_synthesis(self):
        """Two documents with 2+ chunks each triggers synthesis."""
        chunks = [
            {"doc_id": "doc-001", "text": "chunk 1"},
            {"doc_id": "doc-001", "text": "chunk 2"},
            {"doc_id": "doc-002", "text": "chunk 3"},
            {"doc_id": "doc-002", "text": "chunk 4"},
        ]
        assert should_activate_synthesis_mode(chunks) is True

    def test_two_docs_insufficient_chunks(self):
        """Two docs but only 1 chunk each should not trigger synthesis."""
        chunks = [
            {"doc_id": "doc-001", "text": "chunk 1"},
            {"doc_id": "doc-002", "text": "chunk 2"},
        ]
        assert should_activate_synthesis_mode(chunks) is False

    def test_graph_chunks_excluded(self):
        """Graph-derived chunks should not count toward synthesis trigger."""
        chunks = [
            {"doc_id": "doc-001", "text": "chunk 1"},
            {"doc_id": "doc-001", "text": "chunk 2"},
            {"doc_id": "graph", "source": "graph", "text": "entity context"},
            {"doc_id": "graph", "source": "graph", "text": "entity context 2"},
        ]
        assert should_activate_synthesis_mode(chunks) is False

    def test_empty_chunks(self):
        """Empty chunks should return False."""
        assert should_activate_synthesis_mode([]) is False


class TestSynthesisContextBuilding:
    """Tests for synthesis context formatting."""

    def test_context_grouped_by_document(self):
        """Context should be grouped by source document."""
        chunks = [
            {"doc_id": "doc-001", "filename": "Manual A.docx", "text": "Content A1", "page_range": "1-2"},
            {"doc_id": "doc-002", "filename": "Manual B.docx", "text": "Content B1", "page_range": "5-6"},
            {"doc_id": "doc-001", "filename": "Manual A.docx", "text": "Content A2", "page_range": "3-4"},
        ]
        context = build_synthesis_context(chunks)

        assert "=== Manual A.docx ===" in context
        assert "=== Manual B.docx ===" in context
        assert "Content A1" in context
        assert "Content B1" in context

    def test_graph_chunks_marked(self):
        """Graph chunks should be marked with Knowledge Graph header."""
        chunks = [
            {"doc_id": "doc-001", "filename": "Manual.docx", "text": "Doc content", "page_range": "1"},
            {"doc_id": "graph", "filename": "graph", "source": "graph", "entity_name": "GPS Module", "text": "Entity info"},
        ]
        context = build_synthesis_context(chunks)

        assert "Knowledge Graph - GPS Module" in context


class TestCitationModel:
    """Tests for extended Citation model."""

    def test_multi_source_field_default(self):
        """multi_source field should default to False."""
        citation = Citation(
            id=1,
            doc_id="doc-001",
            filename="test.docx",
            page_range="1-2",
            snippet="Test snippet"
        )
        assert citation.multi_source is False

    def test_multi_source_field_true(self):
        """multi_source field can be set to True."""
        citation = Citation(
            id=1,
            doc_id="doc-001",
            filename="test.docx",
            page_range="1-2",
            snippet="Test snippet",
            multi_source=True
        )
        assert citation.multi_source is True

    def test_related_doc_ids_field(self):
        """related_doc_ids field should accept list of doc IDs."""
        citation = Citation(
            id=1,
            doc_id="doc-001",
            filename="test.docx",
            page_range="1-2",
            snippet="Test snippet",
            related_doc_ids=["doc-002", "doc-003"]
        )
        assert len(citation.related_doc_ids) == 2


class TestChatResponseSynthesis:
    """Tests for ChatResponse synthesis fields."""

    def test_synthesis_mode_default(self):
        """synthesis_mode should default to False."""
        response = ChatResponse(
            answer="Test answer",
            citations=[],
            request_id="req-001"
        )
        assert response.synthesis_mode is False
        assert response.source_doc_count == 1

    def test_synthesis_mode_enabled(self):
        """synthesis_mode can be set to True with doc count."""
        response = ChatResponse(
            answer="Multi-source answer",
            citations=[],
            request_id="req-001",
            synthesis_mode=True,
            source_doc_count=3
        )
        assert response.synthesis_mode is True
        assert response.source_doc_count == 3


class TestCrossReferenceDetector:
    """Tests for cross-reference detection patterns."""

    def test_detect_doc_code_pattern(self):
        """Should detect document code patterns like FC-001."""
        detector = CrossReferenceDetector()
        text = "Refer to FC-001 for more details about the flight controller."

        existing_docs = [
            {"doc_id": "doc-fc", "filename": "FC-001-Specification.docx"},
            {"doc_id": "doc-other", "filename": "Other-Document.docx"},
        ]

        refs = detector._detect_explicit_references(text, existing_docs)

        # Should find FC-001 reference
        assert len(refs) >= 1
        assert any(r["target_doc_id"] == "doc-fc" for r in refs)

    def test_detect_see_document_pattern(self):
        """Should detect 'See Document X' patterns."""
        detector = CrossReferenceDetector()
        text = "See the Navigation Manual for calibration procedures."

        existing_docs = [
            {"doc_id": "doc-nav", "filename": "Navigation-Manual.docx"},
        ]

        refs = detector._detect_explicit_references(text, existing_docs)

        # May or may not match depending on fuzzy threshold
        # At minimum should not crash
        assert isinstance(refs, list)


# Skip FalkorDB tests if not available
@pytest.fixture
def skip_if_no_falkordb():
    """Skip test if FalkorDB is not available."""
    try:
        store = DocumentRelationshipStore()
        return store
    except Exception:
        pytest.skip("FalkorDB not available")


class TestDocumentRelationshipStore:
    """Integration tests for DocumentRelationshipStore (requires FalkorDB)."""

    def test_add_document_node(self, skip_if_no_falkordb):
        """Test adding document node to graph."""
        store = skip_if_no_falkordb

        result = store.add_document_node(
            doc_id="test-doc-001",
            filename="test-document.docx",
            user_id="test-user",
            page_count=10,
            chunk_count=25
        )

        assert result is True

        # Cleanup
        store.delete_document_relationships("test-doc-001", "test-user")

    def test_add_and_retrieve_relationship(self, skip_if_no_falkordb):
        """Test adding and retrieving document relationship."""
        store = skip_if_no_falkordb

        # Add two document nodes
        store.add_document_node("test-doc-a", "DocA.docx", "test-user")
        store.add_document_node("test-doc-b", "DocB.docx", "test-user")

        # Add relationship
        rel = DocumentRelationship(
            source_doc_id="test-doc-a",
            target_doc_id="test-doc-b",
            relationship_type="explicit_citation",
            strength=1.0,
            evidence=["See DocB"]
        )
        store.add_relationship(rel, "test-user")

        # Retrieve
        related = store.get_related_documents(
            doc_ids=["test-doc-a"],
            user_id="test-user",
            min_strength=0.5
        )

        assert len(related) >= 1
        assert any(r["doc_id"] == "test-doc-b" for r in related)

        # Cleanup
        store.delete_document_relationships("test-doc-a", "test-user")
        store.delete_document_relationships("test-doc-b", "test-user")
```

Run tests with: `pytest backend/tests/test_multi_source.py -v`
  </action>
  <verify>cd c:/Projects/ironmind && python -m pytest backend/tests/test_multi_source.py -v --tb=short 2>/dev/null || echo "Tests created (run pytest to verify)"</verify>
  <done>Integration tests exist covering schema validation, synthesis mode detection, citation models, and document relationship storage</done>
</task>

</tasks>

<verification>
1. Retriever uses doc relationships: `python -c "from backend.app.services.retriever import HybridRetriever; print('Retriever OK')"`
2. Debug endpoint exists: grep "doc-relationships" backend/app/routers/debug.py
3. Tests pass: `pytest backend/tests/test_multi_source.py -v`
4. End-to-end verification (manual):
   - Upload 2+ documents with shared content
   - Ask question spanning both documents
   - Verify answer uses synthesis mode with multi-source citations
</verification>

<success_criteria>
- HybridRetriever expands results using document relationship graph
- Debug endpoint /api/debug/doc-relationships returns relationship graph
- Debug endpoint /api/debug/doc-relationships/stats returns relationship counts
- Integration tests pass for schema, synthesis detection, and citation models
- Phase 5 success criteria met:
  1. System detects cross-references (explicit + shared entities)
  2. Document relationship graph built during ingestion
  3. Multi-document answers include 3+ source citations when available
  4. Synthesis mode uses consistent entity resolution
  5. Graph-linked entities prioritized in synthesis context
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-source-synthesis/05-04-SUMMARY.md`
</output>
