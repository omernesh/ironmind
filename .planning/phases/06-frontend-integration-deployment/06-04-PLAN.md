---
phase: 06-frontend-integration-deployment
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - infra/docker-compose.prod.yml
  - infra/Caddyfile
  - frontend/Dockerfile
  - backend/Dockerfile
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Production compose file includes Caddy service for HTTPS"
    - "Caddyfile routes to frontend and backend services"
    - "Frontend Dockerfile uses multi-stage build with standalone"
    - "Backend Dockerfile uses Gunicorn with Uvicorn workers"
    - "Caddy data volume persists SSL certificates"
  artifacts:
    - path: "infra/docker-compose.prod.yml"
      provides: "Production orchestration with Caddy"
      contains: "caddy"
    - path: "infra/Caddyfile"
      provides: "Reverse proxy configuration"
      contains: "reverse_proxy"
    - path: "frontend/Dockerfile"
      provides: "Optimized frontend image"
      contains: "standalone"
  key_links:
    - from: "infra/docker-compose.prod.yml"
      to: "infra/Caddyfile"
      via: "volume mount"
      pattern: "Caddyfile:/etc/caddy"
---

<objective>
Configure production Docker deployment with Caddy HTTPS and optimized images

Purpose: Enable secure production deployment on Hetzner VPS with automatic SSL certificates
Output: Production Docker Compose, Caddyfile, and optimized Dockerfiles ready for deployment
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-frontend-integration-deployment/06-RESEARCH.md

# Existing Docker setup
@docker-compose.yml
@frontend/Dockerfile
@backend/Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create infra directory with production Docker Compose</name>
  <files>infra/docker-compose.prod.yml</files>
  <action>
Create `infra/docker-compose.prod.yml`:

```yaml
version: '3.8'

# Production deployment for Hetzner VPS
# Usage: docker-compose -f infra/docker-compose.prod.yml up -d

services:
  # ==========================================================================
  # Caddy - Reverse Proxy with Automatic HTTPS
  # ==========================================================================
  caddy:
    image: caddy:2-alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
      - "443:443/udp"  # HTTP/3 (QUIC)
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data      # CRITICAL: Persists SSL certs
      - caddy_config:/config
    depends_on:
      frontend:
        condition: service_healthy
      backend:
        condition: service_healthy
    networks:
      - ironmind-network

  # ==========================================================================
  # Frontend (Next.js with Better Auth)
  # ==========================================================================
  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
      args:
        - NEXT_PUBLIC_APP_URL=${NEXT_PUBLIC_APP_URL}
        - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - BETTER_AUTH_SECRET=${AUTH_SECRET}
      - DATABASE_PATH=/app/data/auth.db
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    volumes:
      - frontend-data:/app/data
    networks:
      - ironmind-network

  # ==========================================================================
  # Backend (FastAPI with Gunicorn)
  # ==========================================================================
  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
    restart: unless-stopped
    environment:
      - ENVIRONMENT=production
      - SERVICE_NAME=ironmind-backend
      - LOG_LEVEL=INFO
      - CORS_ORIGINS=${CORS_ORIGINS}
      - JWT_SECRET_KEY=${AUTH_SECRET}
      - JWT_ALGORITHM=HS256
      - FALKORDB_URL=redis://falkordb:6379
      - FALKORDB_PASSWORD=${FALKORDB_PASSWORD:-}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - DEEPINFRA_API_KEY=${DEEPINFRA_API_KEY}
      - DOCLING_URL=http://docling:5001
    depends_on:
      falkordb:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    volumes:
      - backend-data:/app/data
    networks:
      - ironmind-network

  # ==========================================================================
  # FalkorDB (Graph Database)
  # ==========================================================================
  falkordb:
    image: falkordb/falkordb:latest
    restart: unless-stopped
    command: --protected-mode no
    volumes:
      - falkordb-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - ironmind-network

  # ==========================================================================
  # Docling Serve (Document Processing)
  # ==========================================================================
  docling:
    image: quay.io/docling-project/docling-serve:v1.10.0
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - ironmind-network

volumes:
  caddy_data:      # Persists SSL certificates - DO NOT DELETE
    driver: local
  caddy_config:
    driver: local
  falkordb-data:
    driver: local
  backend-data:
    driver: local
  frontend-data:
    driver: local

networks:
  ironmind-network:
    driver: bridge
```

IMPORTANT notes:
- No ports exposed for frontend/backend - Caddy handles all external traffic
- NEXT_PUBLIC_* variables passed as build args (not runtime env)
- Caddy data volume preserves SSL certs across restarts
- All services on internal network, only Caddy exposed
  </action>
  <verify>File created with correct YAML syntax</verify>
  <done>Production Docker Compose with Caddy, all services, and persistent volumes</done>
</task>

<task type="auto">
  <name>Task 2: Create Caddyfile for reverse proxy</name>
  <files>infra/Caddyfile</files>
  <action>
Create `infra/Caddyfile`:

```
# IRONMIND Production Caddyfile
# Replace {$DOMAIN} with your actual domain (e.g., ironmind.example.com)

{$DOMAIN} {
    # Frontend - all non-API routes
    reverse_proxy frontend:3000

    # Health check endpoint
    handle /health {
        reverse_proxy backend:8000
    }

    # Security headers
    header {
        X-Content-Type-Options "nosniff"
        X-Frame-Options "DENY"
        X-XSS-Protection "1; mode=block"
        Referrer-Policy "strict-origin-when-cross-origin"
    }

    # Logging
    log {
        output stdout
        format console
    }
}

# API subdomain (optional - can also use path-based routing)
api.{$DOMAIN} {
    reverse_proxy backend:8000

    # CORS headers (backup - also handled by FastAPI)
    header Access-Control-Allow-Origin "{$DOMAIN}"
    header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
    header Access-Control-Allow-Headers "Authorization, Content-Type"

    # Security headers
    header {
        X-Content-Type-Options "nosniff"
        X-Frame-Options "DENY"
    }

    log {
        output stdout
        format console
    }
}

# Alternative: Path-based API routing (use this OR the subdomain above, not both)
# Uncomment below and comment out the api.{$DOMAIN} block if using path-based routing
#
# {$DOMAIN} {
#     handle /api/* {
#         reverse_proxy backend:8000
#     }
#
#     handle {
#         reverse_proxy frontend:3000
#     }
# }
```

Create `.env.production.example` in infra/ directory:

```bash
# infra/.env.production.example
# Copy to .env.production and fill in values

# Domain configuration
DOMAIN=ironmind.yourdomain.com

# URLs (used at build time for frontend)
NEXT_PUBLIC_APP_URL=https://ironmind.yourdomain.com
NEXT_PUBLIC_API_URL=https://api.ironmind.yourdomain.com
CORS_ORIGINS=https://ironmind.yourdomain.com

# Auth secret - generate with: openssl rand -hex 32
AUTH_SECRET=your-secret-here

# API Keys
OPENAI_API_KEY=sk-...
DEEPINFRA_API_KEY=...

# FalkorDB (optional password)
FALKORDB_PASSWORD=
```
  </action>
  <verify>Both Caddyfile and .env.production.example created</verify>
  <done>Caddyfile with HTTPS routing and production environment template</done>
</task>

<task type="auto">
  <name>Task 3: Optimize Dockerfiles for production</name>
  <files>frontend/Dockerfile, backend/Dockerfile</files>
  <action>
1. Update `frontend/Dockerfile` with multi-stage build:

```dockerfile
# ============================================================
# IRONMIND Frontend - Production Dockerfile
# Multi-stage build with standalone output for minimal image
# ============================================================

# Stage 1: Dependencies
FROM node:20-alpine AS deps
WORKDIR /app

# Copy package files
COPY package.json package-lock.json ./

# Install dependencies
RUN npm ci

# Stage 2: Builder
FROM node:20-alpine AS builder
WORKDIR /app

# Copy dependencies from deps stage
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build arguments for NEXT_PUBLIC_* variables (baked into JS at build time)
ARG NEXT_PUBLIC_APP_URL
ARG NEXT_PUBLIC_API_URL
ENV NEXT_PUBLIC_APP_URL=$NEXT_PUBLIC_APP_URL
ENV NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL

# Disable telemetry during build
ENV NEXT_TELEMETRY_DISABLED=1

# Build the application
RUN npm run build

# Stage 3: Runner (production)
FROM node:20-alpine AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

# Create non-root user for security
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# Copy public assets
COPY --from=builder /app/public ./public

# Copy standalone build output
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

# Create data directory for SQLite (Better Auth)
RUN mkdir -p /app/data && chown -R nextjs:nodejs /app/data

USER nextjs

EXPOSE 3000
ENV PORT=3000

# Use Node directly (standalone includes server.js)
CMD ["node", "server.js"]
```

2. Update `backend/Dockerfile` with Gunicorn:

```dockerfile
# ============================================================
# IRONMIND Backend - Production Dockerfile
# Gunicorn with Uvicorn workers for production performance
# ============================================================

FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Install Gunicorn for production
RUN pip install --no-cache-dir gunicorn

# Copy application code
COPY ./app /app/app

# Create non-root user for security
RUN useradd -m -u 1001 appuser && \
    mkdir -p /app/data && \
    chown -R appuser:appuser /app

USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Production server: Gunicorn with Uvicorn workers
# - 4 workers (2x CPU cores typical for I/O bound)
# - 120s timeout for document processing
# - Graceful shutdown with 30s drain
CMD ["gunicorn", "app.main:app", \
     "--workers", "4", \
     "--worker-class", "uvicorn.workers.UvicornWorker", \
     "--bind", "0.0.0.0:8000", \
     "--timeout", "120", \
     "--graceful-timeout", "30", \
     "--access-logfile", "-", \
     "--error-logfile", "-"]
```

3. Create `frontend/.dockerignore`:

```
node_modules
.next
.git
.env*
*.log
.DS_Store
.planning
*.md
!README.md
```

4. Create `backend/.dockerignore`:

```
__pycache__
*.pyc
.git
.env*
*.log
.DS_Store
.planning
tests/
*.md
!README.md
venv/
.venv/
```
  </action>
  <verify>`docker build -t ironmind-frontend ./frontend` and `docker build -t ironmind-backend ./backend` both succeed</verify>
  <done>Optimized Dockerfiles with multi-stage builds and security best practices</done>
</task>

</tasks>

<verification>
1. Create infra/ directory if needed
2. All files created:
   - infra/docker-compose.prod.yml
   - infra/Caddyfile
   - infra/.env.production.example
   - frontend/Dockerfile (updated)
   - backend/Dockerfile (updated)
   - frontend/.dockerignore
   - backend/.dockerignore
3. Build test: `docker build -t test-frontend ./frontend`
4. Build test: `docker build -t test-backend ./backend`
5. YAML validation: `docker-compose -f infra/docker-compose.prod.yml config`
</verification>

<success_criteria>
- INFRA-04 PARTIAL: Production Docker setup ready for Hetzner deployment
- INFRA-06 COMPLETE: Frontend API URL configurable via build args
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-integration-deployment/06-04-SUMMARY.md`
</output>
