---
phase: 06-frontend-integration-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/app/dashboard/page.tsx
  - frontend/app/dashboard/components/DocumentUpload.tsx
  - frontend/app/dashboard/components/DocumentList.tsx
  - frontend/lib/api-client.ts
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "User can drag-drop or click to upload PDF/DOCX files"
    - "User sees upload progress bar during file transfer"
    - "User sees per-document status: Processing, Indexed, Failed"
    - "Document list refreshes to show current status"
    - "User can delete documents from the list"
  artifacts:
    - path: "frontend/app/dashboard/components/DocumentUpload.tsx"
      provides: "Drag-drop upload with progress tracking"
      contains: "useDropzone"
    - path: "frontend/app/dashboard/components/DocumentList.tsx"
      provides: "Document list with status badges"
      contains: "StatusBadge"
    - path: "frontend/app/dashboard/page.tsx"
      provides: "Dashboard orchestrating upload and list"
      contains: "DocumentUpload"
  key_links:
    - from: "frontend/app/dashboard/components/DocumentUpload.tsx"
      to: "/api/documents/upload"
      via: "fetch POST with FormData"
      pattern: "api/documents/upload"
    - from: "frontend/app/dashboard/components/DocumentList.tsx"
      to: "/api/documents"
      via: "fetch GET"
      pattern: "api/documents"
---

<objective>
Build document upload UI with drag-drop, progress tracking, and status display

Purpose: Enable users to upload documents and monitor processing status (INGEST-10 UI requirement)
Output: Dashboard with functional document upload and status list components
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-frontend-integration-deployment/06-RESEARCH.md

# Backend API contracts
@backend/app/routers/documents.py

# Existing frontend
@frontend/app/dashboard/page.tsx
@frontend/lib/api-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and update api-client</name>
  <files>frontend/package.json, frontend/lib/api-client.ts</files>
  <action>
1. Install react-dropzone and axios:
   ```bash
   cd frontend && npm install react-dropzone axios
   ```

2. Update api-client.ts to add file upload method:
   ```typescript
   // Add to apiClient object:
   async uploadFile(endpoint: string, file: File, onProgress?: (progress: number) => void): Promise<any> {
     const token = await getBackendToken();
     const formData = new FormData();
     formData.append("file", file);

     const response = await axios.post(`${API_URL}${endpoint}`, formData, {
       headers: {
         "Content-Type": "multipart/form-data",
         ...(token ? { Authorization: `Bearer ${token}` } : {}),
       },
       onUploadProgress: (progressEvent) => {
         if (progressEvent.total && onProgress) {
           onProgress(Math.round((progressEvent.loaded * 100) / progressEvent.total));
         }
       },
     });

     return response.data;
   },

   async delete(endpoint: string, options?: FetchOptions): Promise<void> {
     const response = await fetchWithAuth(endpoint, { ...options, method: "DELETE" });
     if (!response.ok && response.status !== 204) {
       throw new ApiError(response.status, await response.text());
     }
   },
   ```

3. Add axios import at top of api-client.ts
  </action>
  <verify>`npm run build` in frontend completes without errors</verify>
  <done>API client supports file upload with progress and delete operations</done>
</task>

<task type="auto">
  <name>Task 2: Create DocumentUpload component</name>
  <files>frontend/app/dashboard/components/DocumentUpload.tsx</files>
  <action>
Create `frontend/app/dashboard/components/DocumentUpload.tsx`:

```typescript
"use client";

import { useState, useCallback } from "react";
import { useDropzone, FileRejection } from "react-dropzone";
import { apiClient, ApiError } from "@/lib/api-client";

interface UploadingFile {
  id: string;
  filename: string;
  progress: number;
  status: "uploading" | "done" | "error";
  error?: string;
}

interface DocumentUploadProps {
  onUploadComplete: () => void;
  documentCount: number;
  maxDocuments: number;
}

export function DocumentUpload({ onUploadComplete, documentCount, maxDocuments }: DocumentUploadProps) {
  const [uploadingFiles, setUploadingFiles] = useState<UploadingFile[]>([]);
  const remainingSlots = maxDocuments - documentCount;

  const onDrop = useCallback(async (acceptedFiles: File[], rejectedFiles: FileRejection[]) => {
    // Handle rejections
    if (rejectedFiles.length > 0) {
      rejectedFiles.forEach(rejection => {
        const error = rejection.errors[0]?.message || "Invalid file";
        setUploadingFiles(prev => [...prev, {
          id: crypto.randomUUID(),
          filename: rejection.file.name,
          progress: 0,
          status: "error",
          error,
        }]);
      });
    }

    // Check slot limit
    const filesToUpload = acceptedFiles.slice(0, remainingSlots);
    if (acceptedFiles.length > remainingSlots) {
      alert(`Only ${remainingSlots} upload slot(s) remaining. Some files were not uploaded.`);
    }

    // Upload each file
    for (const file of filesToUpload) {
      const uploadId = crypto.randomUUID();

      setUploadingFiles(prev => [...prev, {
        id: uploadId,
        filename: file.name,
        progress: 0,
        status: "uploading",
      }]);

      try {
        await apiClient.uploadFile("/api/documents/upload", file, (progress) => {
          setUploadingFiles(prev => prev.map(f =>
            f.id === uploadId ? { ...f, progress } : f
          ));
        });

        setUploadingFiles(prev => prev.map(f =>
          f.id === uploadId ? { ...f, status: "done", progress: 100 } : f
        ));

        onUploadComplete();
      } catch (error) {
        const message = error instanceof ApiError
          ? getErrorMessage(error.status)
          : "Upload failed. Please try again.";

        setUploadingFiles(prev => prev.map(f =>
          f.id === uploadId ? { ...f, status: "error", error: message } : f
        ));
      }
    }

    // Clear completed uploads after 3 seconds
    setTimeout(() => {
      setUploadingFiles(prev => prev.filter(f => f.status === "uploading"));
    }, 3000);
  }, [remainingSlots, onUploadComplete]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      "application/pdf": [".pdf"],
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [".docx"],
    },
    maxFiles: remainingSlots,
    disabled: remainingSlots <= 0,
  });

  return (
    <div className="space-y-4">
      {/* Dropzone */}
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors cursor-pointer
          ${isDragActive ? "border-blue-500 bg-blue-50" : "border-gray-300 hover:border-gray-400"}
          ${remainingSlots <= 0 ? "opacity-50 cursor-not-allowed" : ""}`}
        role="button"
        tabIndex={0}
        aria-label="Upload documents. Press space or enter to select files."
      >
        <input {...getInputProps()} aria-label="File upload input" />
        <div className="space-y-2">
          <svg className="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
            <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
          {isDragActive ? (
            <p className="text-blue-600 font-medium">Drop files here...</p>
          ) : remainingSlots <= 0 ? (
            <p className="text-gray-500">Maximum document limit reached</p>
          ) : (
            <>
              <p className="text-gray-700">Drag & drop documents here, or click to select</p>
              <p className="text-sm text-gray-500">PDF, DOCX (max {remainingSlots} files)</p>
            </>
          )}
        </div>
      </div>

      {/* Upload Progress */}
      {uploadingFiles.length > 0 && (
        <div className="space-y-2">
          {uploadingFiles.map(file => (
            <div key={file.id} className="border rounded-lg p-3 bg-gray-50">
              <div className="flex justify-between items-center mb-1">
                <span className="font-medium text-sm truncate max-w-[200px]">{file.filename}</span>
                <UploadStatusBadge status={file.status} />
              </div>

              {file.status === "uploading" && (
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div
                    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                    style={{ width: `${file.progress}%` }}
                    role="progressbar"
                    aria-valuenow={file.progress}
                    aria-valuemin={0}
                    aria-valuemax={100}
                  />
                </div>
              )}

              {file.error && (
                <p className="text-sm text-red-600 mt-1">{file.error}</p>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

function UploadStatusBadge({ status }: { status: UploadingFile["status"] }) {
  const config = {
    uploading: { label: "Uploading...", className: "bg-blue-100 text-blue-800" },
    done: { label: "Uploaded", className: "bg-green-100 text-green-800" },
    error: { label: "Failed", className: "bg-red-100 text-red-800" },
  };

  const { label, className } = config[status];
  return <span className={`px-2 py-0.5 text-xs rounded ${className}`}>{label}</span>;
}

function getErrorMessage(status: number): string {
  const messages: Record<number, string> = {
    400: "Invalid file or limit reached. Please check file format.",
    401: "Session expired. Please log in again.",
    413: "File is too large. Maximum size is 50MB.",
    500: "Server error. Please try again later.",
  };
  return messages[status] || "Upload failed. Please try again.";
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>DocumentUpload component with drag-drop and progress tracking</done>
</task>

<task type="auto">
  <name>Task 3: Create DocumentList component and update Dashboard</name>
  <files>frontend/app/dashboard/components/DocumentList.tsx, frontend/app/dashboard/page.tsx</files>
  <action>
1. Create `frontend/app/dashboard/components/DocumentList.tsx`:

```typescript
"use client";

import { useState } from "react";
import { apiClient, ApiError } from "@/lib/api-client";

interface Document {
  doc_id: string;
  filename: string;
  status: string;  // "Uploading" | "Parsing" | "Chunking" | "Indexing" | "Done" | "Failed"
  file_type: string;
  created_at: string;
  page_count?: number;
  chunk_count?: number;
  error?: string;
}

interface DocumentListProps {
  documents: Document[];
  onRefresh: () => void;
  onDelete: (docId: string) => void;
}

export function DocumentList({ documents, onRefresh, onDelete }: DocumentListProps) {
  const [deletingId, setDeletingId] = useState<string | null>(null);

  const handleDelete = async (docId: string, filename: string) => {
    if (!confirm(`Delete "${filename}"? This cannot be undone.`)) return;

    setDeletingId(docId);
    try {
      await apiClient.delete(`/api/documents/${docId}`);
      onDelete(docId);
    } catch (error) {
      alert("Failed to delete document. Please try again.");
    } finally {
      setDeletingId(null);
    }
  };

  if (documents.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        <p>No documents uploaded yet.</p>
        <p className="text-sm mt-1">Upload your first document to get started.</p>
      </div>
    );
  }

  return (
    <div className="space-y-2">
      {documents.map(doc => (
        <div
          key={doc.doc_id}
          className="border rounded-lg p-4 flex items-center justify-between hover:bg-gray-50"
        >
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-3">
              <FileIcon type={doc.file_type} />
              <div className="min-w-0">
                <p className="font-medium truncate">{doc.filename}</p>
                <p className="text-sm text-gray-500">
                  {doc.page_count ? `${doc.page_count} pages` : ""}
                  {doc.page_count && doc.chunk_count ? " · " : ""}
                  {doc.chunk_count ? `${doc.chunk_count} chunks` : ""}
                  {!doc.page_count && !doc.chunk_count && formatDate(doc.created_at)}
                </p>
              </div>
            </div>
          </div>

          <div className="flex items-center gap-3 ml-4">
            <StatusBadge status={doc.status} error={doc.error} />
            <button
              onClick={() => handleDelete(doc.doc_id, doc.filename)}
              disabled={deletingId === doc.doc_id}
              className="p-1 text-gray-400 hover:text-red-600 disabled:opacity-50"
              title="Delete document"
            >
              {deletingId === doc.doc_id ? (
                <span className="animate-spin">...</span>
              ) : (
                <TrashIcon />
              )}
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}

function StatusBadge({ status, error }: { status: string; error?: string }) {
  // Map internal status to display status (INGEST-10)
  let displayStatus = status;
  if (["Uploading", "Parsing", "Chunking", "Indexing", "GraphExtracting", "DocumentRelationships"].includes(status)) {
    displayStatus = "Processing";
  } else if (status === "Done") {
    displayStatus = "Indexed";
  }

  const config: Record<string, { label: string; className: string }> = {
    Processing: { label: "Processing", className: "bg-yellow-100 text-yellow-800" },
    Indexed: { label: "Indexed", className: "bg-green-100 text-green-800" },
    Failed: { label: "Failed", className: "bg-red-100 text-red-800" },
  };

  const { label, className } = config[displayStatus] || config.Processing;

  return (
    <span
      className={`px-2 py-1 text-xs rounded font-medium ${className}`}
      title={error || `Status: ${status}`}
    >
      {label}
    </span>
  );
}

function FileIcon({ type }: { type: string }) {
  const color = type === "pdf" ? "text-red-500" : "text-blue-500";
  return (
    <svg className={`h-8 w-8 ${color}`} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clipRule="evenodd" />
    </svg>
  );
}

function TrashIcon() {
  return (
    <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
    </svg>
  );
}

function formatDate(dateString: string): string {
  return new Date(dateString).toLocaleDateString(undefined, {
    month: "short",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
}
```

2. Update `frontend/app/dashboard/page.tsx` to integrate both components:

Replace the entire file with a new dashboard that:
- Shows document upload at the top
- Shows document list below
- Polls for status updates on processing documents
- Provides navigation to chat when documents are ready
- Removes the old "test backend" debug UI

Key structure:
```typescript
"use client";

import { useSession, signOut } from "@/lib/auth-client";
import { apiClient, clearTokenCache } from "@/lib/api-client";
import { useRouter } from "next/navigation";
import { useEffect, useState, useCallback } from "react";
import { DocumentUpload } from "./components/DocumentUpload";
import { DocumentList } from "./components/DocumentList";

const MAX_DOCUMENTS = 10;
const POLL_INTERVAL = 3000; // 3 seconds

interface Document {
  doc_id: string;
  filename: string;
  status: string;
  file_type: string;
  created_at: string;
  page_count?: number;
  chunk_count?: number;
  error?: string;
}

export default function DashboardPage() {
  const { data: session, isPending } = useSession();
  const router = useRouter();
  const [documents, setDocuments] = useState<Document[]>([]);
  const [loading, setLoading] = useState(true);

  // Fetch documents
  const fetchDocuments = useCallback(async () => {
    try {
      const docs = await apiClient.get<Document[]>("/api/documents");
      setDocuments(docs);
    } catch (error) {
      console.error("Failed to fetch documents:", error);
    } finally {
      setLoading(false);
    }
  }, []);

  // Initial fetch and polling for processing documents
  useEffect(() => {
    if (session) {
      fetchDocuments();

      // Poll while any document is processing
      const interval = setInterval(() => {
        const hasProcessing = documents.some(d =>
          !["Done", "Failed"].includes(d.status)
        );
        if (hasProcessing) {
          fetchDocuments();
        }
      }, POLL_INTERVAL);

      return () => clearInterval(interval);
    }
  }, [session, fetchDocuments, documents]);

  // Auth redirect
  useEffect(() => {
    if (!isPending && !session) {
      router.push("/login");
    }
  }, [session, isPending, router]);

  const handleSignOut = async () => {
    clearTokenCache();
    await signOut();
    router.push("/");
  };

  const handleDelete = (docId: string) => {
    setDocuments(prev => prev.filter(d => d.doc_id !== docId));
  };

  const indexedCount = documents.filter(d => d.status === "Done").length;

  if (isPending || !session) {
    return <div className="min-h-screen flex items-center justify-center">Loading...</div>;
  }

  return (
    <main className="max-w-4xl mx-auto p-6">
      {/* Header */}
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-2xl font-bold">Documents</h1>
          <p className="text-gray-600">
            {documents.length} of {MAX_DOCUMENTS} documents · {indexedCount} indexed
          </p>
        </div>
        <div className="flex gap-3">
          {indexedCount > 0 && (
            <button
              onClick={() => router.push("/chat")}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Start Chatting
            </button>
          )}
          <button
            onClick={handleSignOut}
            className="px-4 py-2 text-gray-600 hover:text-gray-900"
          >
            Sign Out
          </button>
        </div>
      </div>

      {/* Upload Section */}
      <div className="mb-8">
        <h2 className="text-lg font-semibold mb-3">Upload Documents</h2>
        <DocumentUpload
          onUploadComplete={fetchDocuments}
          documentCount={documents.length}
          maxDocuments={MAX_DOCUMENTS}
        />
      </div>

      {/* Document List */}
      <div>
        <h2 className="text-lg font-semibold mb-3">Your Documents</h2>
        {loading ? (
          <div className="text-center py-8 text-gray-500">Loading...</div>
        ) : (
          <DocumentList
            documents={documents}
            onRefresh={fetchDocuments}
            onDelete={handleDelete}
          />
        )}
      </div>
    </main>
  );
}
```
  </action>
  <verify>`npm run build` completes; `npm run dev` shows dashboard with upload and list</verify>
  <done>Dashboard displays document upload and status list with Processing/Indexed/Failed states</done>
</task>

</tasks>

<verification>
1. `npm run build` in frontend completes
2. Run `npm run dev`, log in, navigate to /dashboard
3. Verify:
   - Drag-drop zone visible with "Drag & drop documents here"
   - Upload a PDF - see progress bar
   - After upload, document appears in list with "Processing" status
   - Status changes to "Indexed" when processing completes
   - Delete button works
   - "Start Chatting" button appears when documents are indexed
</verification>

<success_criteria>
- INGEST-10 COMPLETE: Document status visible in UI (Processing, Indexed, Failed)
- UI-05 COMPLETE: Document list shows upload status per document
- UI-06 PARTIAL: User-friendly error messages on upload failures
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-integration-deployment/06-02-SUMMARY.md`
</output>
