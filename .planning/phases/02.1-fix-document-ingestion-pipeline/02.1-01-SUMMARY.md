---
phase: 02.1-fix-document-ingestion-pipeline
plan: 01
subsystem: document-processing
tags: [docling, structured-parsing, pydantic, document-elements]

dependency-graph:
  requires: [02-02, 02-03]
  provides: [DoclingParseResult, DoclingElement, structured-element-extraction]
  affects: [02.1-02, 02.1-03]

tech-stack:
  added: []
  patterns: [discriminated-union, body-tree-traversal, backward-compatible-dict]

file-tracking:
  key-files:
    created: []
    modified:
      - backend/app/models/documents.py
      - backend/app/services/docling_client.py
      - backend/app/services/pipeline.py

decisions:
  - id: docling-element-hierarchy
    choice: "Discriminated union with Literal types for element_type"
    rationale: "Type-safe element handling with model_dump() serialization support"
  - id: backward-compatible-chunker-input
    choice: "Pass dict format to chunker instead of DoclingParseResult directly"
    rationale: "Chunker in Plan 02 expects Union[Dict, DoclingParseResult] - dict serialization already needed for storage"
  - id: table-is-atomic
    choice: "DoclingTableElement.is_atomic=True by default"
    rationale: "Tables should never be split during chunking - they are semantic units"

metrics:
  duration: 4m
  completed: 2026-01-29
---

# Phase 2.1 Plan 01: Structured Docling Output Extraction Summary

DoclingClient enhanced to extract structured elements from json_content instead of just markdown.

## What Was Built

### 1. DoclingElement Model Hierarchy (backend/app/models/documents.py)

Added Pydantic models for typed document elements:

- **DoclingElement**: Base class with element_type, text, page_number, level
- **DoclingTextElement**: Paragraphs, captions, etc. with label field
- **DoclingTableElement**: Tables with is_atomic=True (never split), num_rows, num_cols
- **DoclingHeadingElement**: Section headers with heading_level 1-6
- **DoclingListItemElement**: List items with marker field
- **DoclingElementUnion**: Discriminated union for type-safe handling
- **DoclingParseResult**: Container with elements list, md_content fallback, page_count

### 2. Enhanced DoclingClient (backend/app/services/docling_client.py)

Updated to extract structured elements from docling-serve response:

- **Request format**: `to_formats=json,md` to get both structured and markdown output
- **_extract_elements()**: Main extraction logic handling multiple response layouts
- **_traverse_body()**: Recursive body tree traversal following $ref pointers
- **_text_item_to_element()**: Convert text items to appropriate element type based on label
- **_table_item_to_element()**: Convert tables with markdown text representation
- **_table_to_markdown()**: Build markdown from table grid/cells data
- **_get_page_number()**: Extract page from prov field or direct page attributes

### 3. Pipeline Integration (backend/app/services/pipeline.py)

Updated process_document() to use new DoclingParseResult:

- Parse result is now typed DoclingParseResult (not Dict[str, Any])
- Serialize elements via model_dump() for storage
- Pass backward-compatible dict format to chunker
- Extract page_count from parse_result.page_count attribute
- Use md_content attribute for cross-reference detection

## Key Implementation Details

**Body Tree Traversal Pattern:**
```python
# DoclingDocument structure: body tree with $ref pointers
body = json_content.get("body", {})
texts = json_content.get("texts", [])  # Actual content array
tables = json_content.get("tables", [])

# Each child has $ref like "#/texts/5" pointing to content
for child in body["children"]:
    ref = child.get("$ref", "")
    if "/texts/" in ref:
        idx = int(ref.split("/texts/")[1])
        element = texts[idx]  # Actual content
```

**Backward-Compatible Chunker Input:**
```python
chunker_input = {
    "document": {"md_content": parse_result.md_content},
    "elements": [e.model_dump() for e in parse_result.elements],
    "page_count": parse_result.page_count
}
```

## Commits

| Hash | Description |
|------|-------------|
| 13fac72 | Add DoclingElement models for structured parsing |
| c474132 | Enhance DoclingClient to extract structured elements |
| b55a4d0 | Update pipeline to use DoclingParseResult |

## Deviations from Plan

### Auto-added Enhancements

**1. [Rule 2 - Missing Critical] Added DoclingListItemElement**
- **Found during:** Task 1
- **Issue:** Plan only specified TextItem, TableItem, SectionHeaderItem but docling also produces list items
- **Fix:** Added DoclingListItemElement with marker field for complete element coverage
- **Files modified:** backend/app/models/documents.py

**2. [Rule 3 - Blocking] Added multiple response layout handling**
- **Found during:** Task 2
- **Issue:** Docling response format varies (body tree vs direct items array)
- **Fix:** Added fallback logic to handle items/elements array when body tree is empty
- **Files modified:** backend/app/services/docling_client.py

## Verification Results

```
parse_document signature: (self, file_path: Path) -> DoclingParseResult
return annotation: <class 'app.models.documents.DoclingParseResult'>
DoclingParseResult.elements type: <class 'list'>
DoclingTextElement.element_type: text
DoclingTableElement.element_type: table
DoclingTableElement.is_atomic: True
DoclingHeadingElement.element_type: section_header

All verification checks passed!
```

## Next Phase Readiness

**Ready for Plan 02.1-02 (Element-Aware Chunker):**
- DoclingParseResult provides structured elements in reading order
- Elements have element_type for discriminated handling
- Tables marked is_atomic=True for atomic chunk treatment
- Page numbers extracted for accurate page_range metadata
- md_content available as fallback if elements extraction fails

**Integration Points for Plan 02:**
- Chunker receives dict with `elements` key containing serialized DoclingElement dicts
- Each element dict has `element_type` field for type detection
- Tables have `is_atomic: true` - chunker should never split them
- Headings have `heading_level` for section boundary detection
