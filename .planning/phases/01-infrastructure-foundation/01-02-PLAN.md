---
phase: 01-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - frontend/package.json
  - frontend/app/api/auth/[...all]/route.ts
  - frontend/lib/auth.ts
  - frontend/lib/auth-client.ts
  - frontend/app/layout.tsx
  - frontend/app/page.tsx
  - frontend/app/(auth)/login/page.tsx
  - frontend/app/(auth)/register/page.tsx
  - frontend/.env.local.example
  - frontend/Dockerfile
  - frontend/next.config.js
autonomous: true

user_setup:
  - service: mailgun
    why: "Better Auth email verification and password reset"
    env_vars:
      - name: MAILGUN_SMTP_LOGIN
        source: "Mailgun Dashboard -> Sending -> Domain Settings -> SMTP credentials"
      - name: MAILGUN_SMTP_PASSWORD
        source: "Mailgun Dashboard -> Sending -> Domain Settings -> SMTP credentials"
      - name: MAIL_FROM
        source: "Your verified sender email (e.g., noreply@ironmind.chat)"

must_haves:
  truths:
    - "User can register with email and password via /register page"
    - "User can login via /login page"
    - "User session persists across browser refresh"
    - "Invalid credentials show error message on login page"
    - "Registration form validates email format and password length"
  artifacts:
    - path: "frontend/lib/auth.ts"
      provides: "Better Auth server configuration with email/password"
      contains: "betterAuth"
    - path: "frontend/lib/auth-client.ts"
      provides: "Better Auth React client hooks"
      exports: ["authClient", "signIn", "signUp", "signOut"]
    - path: "frontend/app/api/auth/[...all]/route.ts"
      provides: "Better Auth API route handler"
      contains: "auth.handler"
    - path: "frontend/app/(auth)/login/page.tsx"
      provides: "Login form component"
      min_lines: 30
    - path: "frontend/app/(auth)/register/page.tsx"
      provides: "Registration form component"
      min_lines: 30
    - path: "frontend/Dockerfile"
      provides: "Production Docker image for Next.js"
      contains: "node:20"
  key_links:
    - from: "frontend/app/(auth)/login/page.tsx"
      to: "frontend/lib/auth-client.ts"
      via: "signIn function call"
      pattern: "signIn"
    - from: "frontend/app/api/auth/[...all]/route.ts"
      to: "frontend/lib/auth.ts"
      via: "auth.handler export"
      pattern: "auth\\.handler"
---

<objective>
Set up Better Auth for frontend authentication with email/password support.

Purpose: Enable user registration and login via Better Auth, providing session management that persists across browser refresh. This creates the authentication foundation that backend will validate against.
Output: Working Next.js frontend with Better Auth configured, login/register pages, and session persistence.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Next.js project and configure Better Auth</name>
  <files>
    frontend/package.json
    frontend/app/api/auth/[...all]/route.ts
    frontend/lib/auth.ts
    frontend/lib/auth-client.ts
    frontend/.env.local.example
    frontend/next.config.js
  </files>
  <action>
1. Create Next.js project structure:
   - `npx create-next-app@latest frontend --typescript --tailwind --eslint --app --src-dir=false --import-alias="@/*" --use-npm`
   - Navigate to frontend directory

2. Install Better Auth dependencies:
   - `npm install better-auth @better-auth/react`
   - `npm install better-sqlite3` (for POC local database)

3. Create `frontend/lib/auth.ts` (Better Auth server config):
```typescript
import { betterAuth } from "better-auth";
import Database from "better-sqlite3";

export const auth = betterAuth({
  database: new Database("./auth.db"),  // SQLite for POC simplicity
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: false,  // Disable for POC speed
    minPasswordLength: 8,
  },
  session: {
    expiresIn: 60 * 60 * 24 * 7,  // 7 days
    updateAge: 60 * 60 * 24,  // Update session every 24 hours
    cookieCache: {
      enabled: true,
      maxAge: 60 * 5,  // 5 minute cookie cache
    },
  },
  trustedOrigins: [
    process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000",
  ],
});
```

4. Create `frontend/lib/auth-client.ts` (React client):
```typescript
import { createAuthClient } from "better-auth/react";

export const authClient = createAuthClient({
  baseURL: process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000",
});

export const { signIn, signUp, signOut, useSession } = authClient;
```

5. Create `frontend/app/api/auth/[...all]/route.ts`:
```typescript
import { auth } from "@/lib/auth";
import { toNextJsHandler } from "better-auth/next-js";

export const { POST, GET } = toNextJsHandler(auth);
```

6. Create `frontend/.env.local.example`:
```
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:8000
BETTER_AUTH_SECRET=your-secret-key-change-in-production
```

7. Update `frontend/next.config.js` to handle better-auth:
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: {
      bodySizeLimit: '2mb',
    },
  },
  // For Docker internal networking
  output: 'standalone',
}

module.exports = nextConfig
```

IMPORTANT: Better Auth with SQLite requires Node.js native modules. For Docker build, we'll handle this in Task 3.
  </action>
  <verify>
    - `cat frontend/package.json | grep better-auth` shows better-auth installed
    - `cat frontend/lib/auth.ts` shows betterAuth configuration
    - `cat frontend/lib/auth-client.ts` shows createAuthClient
    - `cat frontend/app/api/auth/*/route.ts` shows auth.handler
  </verify>
  <done>Better Auth configured with email/password authentication, SQLite database for POC, session management with 7-day expiry and cookie caching.</done>
</task>

<task type="auto">
  <name>Task 2: Create login and registration pages</name>
  <files>
    frontend/app/layout.tsx
    frontend/app/page.tsx
    frontend/app/(auth)/login/page.tsx
    frontend/app/(auth)/register/page.tsx
    frontend/components/auth-form.tsx
  </files>
  <action>
1. Update `frontend/app/layout.tsx`:
   - Keep existing Tailwind setup
   - Add metadata: title "IRONMIND", description "Technical Document Intelligence"

2. Create `frontend/app/page.tsx` (landing page):
```tsx
import Link from "next/link";

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <h1 className="text-4xl font-bold mb-8">IRONMIND</h1>
      <p className="text-lg text-gray-600 mb-8">
        Technical Document Intelligence for Aerospace & Defense
      </p>
      <div className="flex gap-4">
        <Link
          href="/login"
          className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
        >
          Login
        </Link>
        <Link
          href="/register"
          className="px-6 py-3 border border-blue-600 text-blue-600 rounded-lg hover:bg-blue-50"
        >
          Register
        </Link>
      </div>
    </main>
  );
}
```

3. Create `frontend/components/auth-form.tsx` (shared form component):
```tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { signIn, signUp } from "@/lib/auth-client";

interface AuthFormProps {
  mode: "login" | "register";
}

export function AuthForm({ mode }: AuthFormProps) {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setLoading(true);

    try {
      if (mode === "register") {
        const result = await signUp.email({
          email,
          password,
          name,
        });
        if (result.error) {
          setError(result.error.message || "Registration failed");
          return;
        }
      } else {
        const result = await signIn.email({
          email,
          password,
        });
        if (result.error) {
          setError(result.error.message || "Invalid credentials");
          return;
        }
      }
      router.push("/dashboard");
    } catch (err) {
      setError("An unexpected error occurred");
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="w-full max-w-md space-y-4">
      {error && (
        <div className="p-3 bg-red-100 border border-red-400 text-red-700 rounded">
          {error}
        </div>
      )}

      {mode === "register" && (
        <div>
          <label htmlFor="name" className="block text-sm font-medium mb-1">
            Name
          </label>
          <input
            id="name"
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
            required
          />
        </div>
      )}

      <div>
        <label htmlFor="email" className="block text-sm font-medium mb-1">
          Email
        </label>
        <input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
          required
        />
      </div>

      <div>
        <label htmlFor="password" className="block text-sm font-medium mb-1">
          Password
        </label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
          minLength={8}
          required
        />
        {mode === "register" && (
          <p className="text-xs text-gray-500 mt-1">Minimum 8 characters</p>
        )}
      </div>

      <button
        type="submit"
        disabled={loading}
        className="w-full py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
      >
        {loading ? "Please wait..." : mode === "login" ? "Login" : "Register"}
      </button>
    </form>
  );
}
```

4. Create `frontend/app/(auth)/login/page.tsx`:
```tsx
import Link from "next/link";
import { AuthForm } from "@/components/auth-form";

export default function LoginPage() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-8">
      <h1 className="text-3xl font-bold mb-8">Login to IRONMIND</h1>
      <AuthForm mode="login" />
      <p className="mt-4 text-sm text-gray-600">
        Don't have an account?{" "}
        <Link href="/register" className="text-blue-600 hover:underline">
          Register
        </Link>
      </p>
    </main>
  );
}
```

5. Create `frontend/app/(auth)/register/page.tsx`:
```tsx
import Link from "next/link";
import { AuthForm } from "@/components/auth-form";

export default function RegisterPage() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-8">
      <h1 className="text-3xl font-bold mb-8">Create IRONMIND Account</h1>
      <AuthForm mode="register" />
      <p className="mt-4 text-sm text-gray-600">
        Already have an account?{" "}
        <Link href="/login" className="text-blue-600 hover:underline">
          Login
        </Link>
      </p>
    </main>
  );
}
```

6. Create placeholder `frontend/app/dashboard/page.tsx`:
```tsx
"use client";

import { useSession, signOut } from "@/lib/auth-client";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function DashboardPage() {
  const { data: session, isPending } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (!isPending && !session) {
      router.push("/login");
    }
  }, [session, isPending, router]);

  if (isPending) {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return null;
  }

  return (
    <main className="p-8">
      <h1 className="text-2xl font-bold mb-4">Dashboard</h1>
      <p className="mb-4">Welcome, {session.user.name || session.user.email}</p>
      <p className="text-sm text-gray-600 mb-4">User ID: {session.user.id}</p>
      <button
        onClick={() => signOut().then(() => router.push("/"))}
        className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
      >
        Sign Out
      </button>
    </main>
  );
}
```
  </action>
  <verify>
    - `ls frontend/app/(auth)/` shows login/ and register/ directories
    - `cat frontend/components/auth-form.tsx` shows form handling with signIn/signUp
    - `npm run build` in frontend directory succeeds (or at least no syntax errors)
  </verify>
  <done>Login and register pages created with shared AuthForm component. Dashboard page shows session info and sign out button. Session persists across refresh via Better Auth cookie management.</done>
</task>

<task type="auto">
  <name>Task 3: Create frontend Dockerfile</name>
  <files>
    frontend/Dockerfile
    frontend/.dockerignore
  </files>
  <action>
1. Create `frontend/.dockerignore`:
```
node_modules
.next
.git
*.md
.env*.local
auth.db
```

2. Create `frontend/Dockerfile` (multi-stage build for production):
```dockerfile
# Stage 1: Dependencies
FROM node:20-alpine AS deps
WORKDIR /app

# Install dependencies for native modules (better-sqlite3)
RUN apk add --no-cache python3 make g++

COPY package.json package-lock.json ./
RUN npm ci

# Stage 2: Build
FROM node:20-alpine AS builder
WORKDIR /app

# Install build dependencies for better-sqlite3
RUN apk add --no-cache python3 make g++

COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Set production environment for build
ENV NEXT_TELEMETRY_DISABLED=1
ENV NODE_ENV=production

RUN npm run build

# Stage 3: Production
FROM node:20-alpine AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

# Create non-root user
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# Copy built application
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

# Create data directory for SQLite (auth.db)
RUN mkdir -p /app/data && chown nextjs:nodejs /app/data

USER nextjs

EXPOSE 3000

ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/ || exit 1

CMD ["node", "server.js"]
```

IMPORTANT: The Dockerfile uses standalone output mode (configured in next.config.js). This creates a minimal production build.

Note on SQLite in Docker:
- auth.db will be created in the container's /app directory
- For persistence across container restarts, mount a volume: `-v ./data:/app/data`
- Update auth.ts to use `/app/data/auth.db` path when DATABASE_PATH env var is set
  </action>
  <verify>
    - `cat frontend/Dockerfile` shows multi-stage build with node:20-alpine
    - `cat frontend/.dockerignore` excludes node_modules and .next
    - `docker build -t ironmind-frontend ./frontend` succeeds
  </verify>
  <done>Frontend Dockerfile created with multi-stage build, non-root user, and healthcheck. SQLite native module dependencies handled during build.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Start frontend: `cd frontend && npm run dev`
2. Visit http://localhost:3000 - see landing page with Login/Register buttons
3. Visit http://localhost:3000/register - register a new user
4. After registration, redirected to /dashboard showing user info
5. Refresh browser - session persists (still on dashboard)
6. Click Sign Out - returned to home page
7. Visit /login - log in with registered credentials
8. Build Docker: `docker build -t ironmind-frontend ./frontend` - expect success
</verification>

<success_criteria>
- User can register with email/password at /register
- User can login at /login
- Invalid credentials show error message (not crash)
- Session persists after browser refresh (cookie-based)
- Dashboard shows user ID (needed for backend correlation)
- Docker build succeeds with node:20-alpine base
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md`
</output>
