---
phase: 01-infrastructure-foundation
plan: 05
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - frontend/app/api/auth/backend-token/route.ts
  - frontend/lib/api-client.ts
  - frontend/app/dashboard/page.tsx
autonomous: false

must_haves:
  truths:
    - "Authenticated frontend request to /api/protected returns user_id"
    - "Unauthenticated frontend request shows proper error handling"
    - "User can complete full flow: register -> login -> see dashboard with user_id -> logout"
    - "Backend logs show user_id for authenticated requests"
  artifacts:
    - path: "frontend/app/api/auth/backend-token/route.ts"
      provides: "Token exchange endpoint that converts Better Auth session to backend JWT"
      exports: ["GET"]
    - path: "frontend/lib/api-client.ts"
      provides: "API client that fetches backend token and attaches to requests"
      exports: ["apiClient", "fetchWithAuth"]
  key_links:
    - from: "frontend/lib/api-client.ts"
      to: "frontend/app/api/auth/backend-token/route.ts"
      via: "fetch to /api/auth/backend-token"
      pattern: "fetch.*api/auth/backend-token"
    - from: "frontend/app/api/auth/backend-token/route.ts"
      to: "frontend/lib/auth.ts"
      via: "auth.api.getSession for session validation"
      pattern: "auth\\.api\\.getSession"
    - from: "frontend/app/dashboard/page.tsx"
      to: "frontend/lib/api-client.ts"
      via: "fetchWithAuth for protected endpoints"
      pattern: "fetchWithAuth"
    - from: "frontend/lib/api-client.ts"
      to: "backend/app/routers/protected.py"
      via: "HTTP request with Authorization header"
      pattern: "Authorization.*Bearer"
---

<objective>
Complete frontend-backend auth integration with deterministic token exchange.

Purpose: Connect frontend Better Auth sessions to backend JWT validation via a token exchange endpoint. This ensures tokens are properly passed and validated without relying on speculative Better Auth behavior.
Output: Working end-to-end auth flow where Better Auth session is exchanged for a backend-compatible JWT, and human verification of the complete user journey.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-03-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token exchange endpoint and API client</name>
  <files>
    frontend/app/api/auth/backend-token/route.ts
    frontend/lib/api-client.ts
    frontend/app/dashboard/page.tsx
  </files>
  <action>
**Why token exchange is needed:**
Better Auth uses cookie-based sessions, not JWT tokens. The backend expects `Authorization: Bearer <jwt>`.
We need an explicit token exchange: Better Auth session -> backend JWT.

**1. Install jose library for JWT creation:**
```bash
cd frontend && npm install jose
```

**2. Create `frontend/app/api/auth/backend-token/route.ts`:**
```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { SignJWT } from "jose";

/**
 * Token Exchange Endpoint
 *
 * Converts a valid Better Auth session into a JWT token that the backend can validate.
 *
 * Flow:
 * 1. Client calls this endpoint with Better Auth session cookie
 * 2. We validate the session server-side via Better Auth
 * 3. We create a JWT with the user's ID using the shared secret
 * 4. Client uses this JWT for backend API calls
 *
 * Security:
 * - JWT uses same secret as backend (BETTER_AUTH_SECRET = JWT_SECRET_KEY)
 * - JWT expires in 15 minutes (short-lived for security)
 * - User must have valid Better Auth session to get a backend token
 */

export async function GET(request: NextRequest) {
  try {
    // Get the current session from Better Auth
    const session = await auth.api.getSession({
      headers: await headers(),
    });

    if (!session || !session.user) {
      return NextResponse.json(
        { error: "Not authenticated" },
        { status: 401 }
      );
    }

    // Get shared secret from environment
    const secret = process.env.BETTER_AUTH_SECRET;
    if (!secret) {
      console.error("BETTER_AUTH_SECRET not configured");
      return NextResponse.json(
        { error: "Server configuration error" },
        { status: 500 }
      );
    }

    // Create JWT for backend using jose library
    // Must match backend expectations:
    // - Algorithm: HS256
    // - Claim: "sub" contains user_id
    const secretKey = new TextEncoder().encode(secret);

    const token = await new SignJWT({ sub: session.user.id })
      .setProtectedHeader({ alg: "HS256" })
      .setIssuedAt()
      .setExpirationTime("15m")  // Short-lived token
      .sign(secretKey);

    return NextResponse.json({
      token,
      expiresIn: 900,  // 15 minutes in seconds
      userId: session.user.id,
    });
  } catch (error) {
    console.error("Token exchange error:", error);
    return NextResponse.json(
      { error: "Token exchange failed" },
      { status: 500 }
    );
  }
}
```

**3. Create `frontend/lib/api-client.ts`:**
```typescript
/**
 * API Client for Backend Communication
 *
 * Uses token exchange pattern:
 * 1. Fetch backend token from /api/auth/backend-token (validates Better Auth session)
 * 2. Cache token until near expiry
 * 3. Attach token as Bearer header to all backend requests
 */

// Backend API URL - browser requests go to localhost
const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";

interface FetchOptions extends RequestInit {
  skipAuth?: boolean;
}

// Token cache
let cachedToken: string | null = null;
let tokenExpiry: number = 0;

/**
 * Get or refresh the backend token.
 * Caches token until 1 minute before expiry.
 */
async function getBackendToken(): Promise<string | null> {
  const now = Date.now();
  const bufferMs = 60 * 1000; // Refresh 1 minute before expiry

  // Return cached token if still valid
  if (cachedToken && tokenExpiry > now + bufferMs) {
    return cachedToken;
  }

  try {
    // Fetch new token from exchange endpoint
    const response = await fetch("/api/auth/backend-token", {
      credentials: "include", // Include Better Auth session cookie
    });

    if (!response.ok) {
      if (response.status === 401) {
        // Not authenticated - clear cache and return null
        cachedToken = null;
        tokenExpiry = 0;
        return null;
      }
      throw new Error(`Token exchange failed: ${response.status}`);
    }

    const data = await response.json();

    // Cache the token
    cachedToken = data.token;
    tokenExpiry = now + (data.expiresIn * 1000);

    return cachedToken;
  } catch (error) {
    console.error("Failed to get backend token:", error);
    return null;
  }
}

/**
 * Clear the token cache (call on logout).
 */
export function clearTokenCache(): void {
  cachedToken = null;
  tokenExpiry = 0;
}

/**
 * Fetch wrapper that attaches authentication token.
 */
export async function fetchWithAuth(
  endpoint: string,
  options: FetchOptions = {}
): Promise<Response> {
  const { skipAuth = false, headers: customHeaders, ...restOptions } = options;

  const headers = new Headers(customHeaders);

  if (!skipAuth) {
    const token = await getBackendToken();
    if (token) {
      headers.set("Authorization", `Bearer ${token}`);
    }
  }

  // Always set JSON content type for API requests
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json");
  }

  const url = endpoint.startsWith("/") ? `${API_URL}${endpoint}` : endpoint;

  return fetch(url, {
    ...restOptions,
    headers,
  });
}

/**
 * API client with convenience methods.
 */
export const apiClient = {
  async get<T>(endpoint: string, options?: FetchOptions): Promise<T> {
    const response = await fetchWithAuth(endpoint, { ...options, method: "GET" });

    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }

    return response.json();
  },

  async post<T>(endpoint: string, data?: unknown, options?: FetchOptions): Promise<T> {
    const response = await fetchWithAuth(endpoint, {
      ...options,
      method: "POST",
      body: data ? JSON.stringify(data) : undefined,
    });

    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }

    return response.json();
  },
};

class ApiError extends Error {
  constructor(public status: number, public body: string) {
    super(`API Error ${status}: ${body}`);
    this.name = "ApiError";
  }
}

export { ApiError };
```

**4. Update `frontend/app/dashboard/page.tsx`:**
```tsx
"use client";

import { useSession, signOut } from "@/lib/auth-client";
import { apiClient, ApiError, clearTokenCache } from "@/lib/api-client";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";

interface ProtectedResponse {
  message: string;
  user_id: string;
}

export default function DashboardPage() {
  const { data: session, isPending } = useSession();
  const router = useRouter();
  const [backendResponse, setBackendResponse] = useState<ProtectedResponse | null>(null);
  const [backendError, setBackendError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!isPending && !session) {
      router.push("/login");
    }
  }, [session, isPending, router]);

  // Test backend integration
  const testBackendAuth = async () => {
    setLoading(true);
    setBackendError(null);
    setBackendResponse(null);

    try {
      const response = await apiClient.get<ProtectedResponse>("/api/protected");
      setBackendResponse(response);
    } catch (error) {
      if (error instanceof ApiError) {
        setBackendError(`Backend returned ${error.status}: ${error.body}`);
      } else {
        setBackendError("Failed to connect to backend");
      }
    } finally {
      setLoading(false);
    }
  };

  const handleSignOut = async () => {
    clearTokenCache(); // Clear backend token cache
    await signOut();
    router.push("/");
  };

  if (isPending) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-lg">Loading...</div>
      </div>
    );
  }

  if (!session) {
    return null;
  }

  return (
    <main className="p-8 max-w-2xl mx-auto">
      <h1 className="text-2xl font-bold mb-6">IRONMIND Dashboard</h1>

      {/* Session Info */}
      <div className="bg-gray-50 rounded-lg p-4 mb-6">
        <h2 className="font-semibold mb-2">Session Info</h2>
        <p className="text-sm">
          <span className="text-gray-600">Name:</span> {session.user.name || "Not set"}
        </p>
        <p className="text-sm">
          <span className="text-gray-600">Email:</span> {session.user.email}
        </p>
        <p className="text-sm">
          <span className="text-gray-600">User ID:</span>{" "}
          <code className="bg-gray-200 px-1 rounded">{session.user.id}</code>
        </p>
      </div>

      {/* Backend Integration Test */}
      <div className="bg-blue-50 rounded-lg p-4 mb-6">
        <h2 className="font-semibold mb-2">Backend Integration</h2>
        <button
          onClick={testBackendAuth}
          disabled={loading}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {loading ? "Testing..." : "Test Protected Endpoint"}
        </button>

        {backendResponse && (
          <div className="mt-4 p-3 bg-green-100 border border-green-400 rounded">
            <p className="text-green-700 font-medium">Backend Auth Working!</p>
            <p className="text-sm">
              Backend user_id: <code>{backendResponse.user_id}</code>
            </p>
            <p className="text-sm text-gray-600">{backendResponse.message}</p>
          </div>
        )}

        {backendError && (
          <div className="mt-4 p-3 bg-red-100 border border-red-400 rounded">
            <p className="text-red-700 font-medium">Backend Auth Failed</p>
            <p className="text-sm">{backendError}</p>
          </div>
        )}
      </div>

      {/* Sign Out */}
      <button
        onClick={handleSignOut}
        className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
      >
        Sign Out
      </button>
    </main>
  );
}
```
  </action>
  <verify>
**Automated verification (run these commands):**

1. Verify token exchange endpoint exists and exports GET:
```bash
cat frontend/app/api/auth/backend-token/route.ts | grep -E "export async function GET"
```
Expected: Shows `export async function GET`

2. Verify api-client uses token exchange:
```bash
cat frontend/lib/api-client.ts | grep -E "api/auth/backend-token"
```
Expected: Shows fetch to `/api/auth/backend-token`

3. Verify Authorization header is set:
```bash
cat frontend/lib/api-client.ts | grep -E "Authorization.*Bearer"
```
Expected: Shows `headers.set("Authorization", \`Bearer \${token}\`)`

4. Verify jose is installed:
```bash
cat frontend/package.json | grep jose
```
Expected: Shows jose in dependencies

5. Build test - verify no TypeScript errors:
```bash
cd frontend && npm run build
```
Expected: Build succeeds without errors

6. Integration test - verify token exchange endpoint works:
```bash
# Start services first: docker-compose up -d
# Register a user via UI at http://localhost:3000/register
# Then test token exchange (with session cookie from browser):
curl -v http://localhost:3000/api/auth/backend-token
```
Expected: Returns 401 (no session) or 200 with token (if logged in via browser)
  </verify>
  <done>Token exchange endpoint created at /api/auth/backend-token that converts Better Auth sessions to backend-compatible JWT. API client fetches and caches this token, attaching it as Bearer header to all backend requests. Flow is deterministic: Better Auth session -> token exchange -> backend JWT.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 authentication and infrastructure with deterministic token exchange:
- Backend: FastAPI with health endpoint, structured logging, JWT validation
- Frontend: Next.js with Better Auth, login/register pages, session management
- Token Exchange: /api/auth/backend-token converts sessions to backend JWTs
- Docker Compose: Orchestration for frontend, backend, FalkorDB
- Integration: API client that fetches backend token and attaches to requests
  </what-built>
  <how-to-verify>
1. **Start the stack:**
   ```bash
   cp .env.example .env
   # Generate secret: openssl rand -base64 32
   # Add to .env as AUTH_SECRET=<generated-value>
   docker-compose up --build
   ```

2. **Verify services are healthy:**
   ```bash
   docker-compose ps
   # All services should show "healthy" status
   ```

3. **Test the auth flow:**
   - Open http://localhost:3000 in browser
   - Click "Register"
   - Create account with email/password (min 8 chars)
   - Should redirect to dashboard after registration
   - Dashboard shows session info with user ID

4. **Test backend integration (THE KEY TEST):**
   - On dashboard, click "Test Protected Endpoint"
   - **Expected:** Green success message with backend user_id
   - This confirms the token exchange is working:
     - Better Auth session is valid
     - Token exchange endpoint created JWT
     - Backend validated the JWT and extracted user_id

5. **Verify session persistence:**
   - Refresh the browser (Ctrl+F5)
   - Should still be on dashboard (session persists)

6. **Test logout:**
   - Click "Sign Out"
   - Should return to home page

7. **Test protected endpoint without auth:**
   ```bash
   curl -i http://localhost:8000/api/protected
   # Should return 401 Unauthorized
   ```

8. **Check backend logs:**
   ```bash
   docker-compose logs backend
   # Should show structured JSON logs with request_id
   # Authenticated requests should show user_id
   ```
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass (especially step 4 - backend integration), or describe issues encountered.
  </resume-signal>
</task>

</tasks>

<verification>
Human verification checkpoint validates:
1. Docker Compose orchestrates all services successfully
2. User registration and login work via Better Auth
3. Session persists across browser refresh
4. Token exchange endpoint creates valid JWT from Better Auth session
5. Backend receives and validates JWT tokens (via Authorization header)
6. Structured logging includes user_id for authenticated requests
7. Unauthenticated requests properly return 401
</verification>

<success_criteria>
- [Human Verified] User can register, login, and session persists
- [Human Verified] Dashboard "Test Protected Endpoint" returns success with user_id
- [Human Verified] Backend logs show user_id for authenticated requests
- [Human Verified] curl without auth to /api/protected returns 401
- [Human Verified] Docker Compose starts all services with healthy status
</success_criteria>

<output>
After completion (including human verification), create `.planning/phases/01-infrastructure-foundation/01-05-SUMMARY.md`
</output>
