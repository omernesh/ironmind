---
phase: 01-infrastructure-foundation
plan: 05
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - frontend/lib/api-client.ts
  - frontend/app/dashboard/page.tsx
autonomous: false

must_haves:
  truths:
    - "Authenticated frontend request to /api/protected returns user_id"
    - "Unauthenticated frontend request shows proper error handling"
    - "User can complete full flow: register -> login -> see dashboard with user_id -> logout"
    - "Backend logs show user_id for authenticated requests"
  artifacts:
    - path: "frontend/lib/api-client.ts"
      provides: "API client that attaches auth tokens to backend requests"
      exports: ["apiClient", "fetchWithAuth"]
  key_links:
    - from: "frontend/app/dashboard/page.tsx"
      to: "frontend/lib/api-client.ts"
      via: "fetchWithAuth for protected endpoints"
      pattern: "fetchWithAuth"
    - from: "frontend/lib/api-client.ts"
      to: "backend/app/routers/protected.py"
      via: "HTTP request with Authorization header"
      pattern: "Authorization.*Bearer"
---

<objective>
Complete frontend-backend auth integration and verify end-to-end flow.

Purpose: Connect frontend authentication to backend API, ensuring tokens are properly passed and validated. This validates the entire auth chain works before building on it in later phases.
Output: Working end-to-end auth flow with API client that attaches tokens, and human verification of the complete user journey.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-03-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API client with auth token handling</name>
  <files>
    frontend/lib/api-client.ts
    frontend/app/dashboard/page.tsx
  </files>
  <action>
Create an API client that handles authentication for backend requests.

IMPORTANT: Better Auth session management may differ from standard JWT. We need to handle two scenarios:
1. If Better Auth provides a JWT access token, attach it as Bearer token
2. If Better Auth uses session cookies only, we may need a proxy approach

1. Create `frontend/lib/api-client.ts`:
```typescript
import { authClient } from "./auth-client";

// Backend API URL - different in browser vs server-side
const API_URL = typeof window !== "undefined"
  ? process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000"
  : process.env.NEXT_PUBLIC_API_URL || "http://backend:8000";

interface FetchOptions extends RequestInit {
  skipAuth?: boolean;
}

/**
 * Fetch wrapper that attaches authentication token if available.
 *
 * Better Auth may provide token via:
 * 1. Session object with accessToken
 * 2. Cookie that needs to be forwarded
 *
 * This implementation handles both cases.
 */
export async function fetchWithAuth(
  endpoint: string,
  options: FetchOptions = {}
): Promise<Response> {
  const { skipAuth = false, headers: customHeaders, ...restOptions } = options;

  const headers = new Headers(customHeaders);

  if (!skipAuth) {
    // Try to get session and token from Better Auth
    try {
      const session = await authClient.getSession();

      if (session?.data?.session) {
        // Better Auth stores session token in session object
        // We'll use the session token as Bearer token
        // Note: This may need adjustment based on Better Auth's actual token format
        const token = (session.data as any).token || (session.data as any).accessToken;

        if (token) {
          headers.set("Authorization", `Bearer ${token}`);
        }
      }
    } catch (error) {
      console.warn("Failed to get auth session:", error);
    }
  }

  // Always set JSON content type for API requests
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json");
  }

  const url = endpoint.startsWith("/") ? `${API_URL}${endpoint}` : endpoint;

  return fetch(url, {
    ...restOptions,
    headers,
    credentials: "include",  // Include cookies for CORS
  });
}

/**
 * API client with convenience methods.
 */
export const apiClient = {
  async get<T>(endpoint: string, options?: FetchOptions): Promise<T> {
    const response = await fetchWithAuth(endpoint, { ...options, method: "GET" });

    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }

    return response.json();
  },

  async post<T>(endpoint: string, data?: unknown, options?: FetchOptions): Promise<T> {
    const response = await fetchWithAuth(endpoint, {
      ...options,
      method: "POST",
      body: data ? JSON.stringify(data) : undefined,
    });

    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }

    return response.json();
  },

  // Add more methods as needed
};

class ApiError extends Error {
  constructor(public status: number, public body: string) {
    super(`API Error ${status}: ${body}`);
    this.name = "ApiError";
  }
}

export { ApiError };
```

2. Update `frontend/app/dashboard/page.tsx` to test backend integration:
```tsx
"use client";

import { useSession, signOut } from "@/lib/auth-client";
import { apiClient, ApiError } from "@/lib/api-client";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";

interface ProtectedResponse {
  message: string;
  user_id: string;
}

export default function DashboardPage() {
  const { data: session, isPending } = useSession();
  const router = useRouter();
  const [backendResponse, setBackendResponse] = useState<ProtectedResponse | null>(null);
  const [backendError, setBackendError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!isPending && !session) {
      router.push("/login");
    }
  }, [session, isPending, router]);

  // Test backend integration
  const testBackendAuth = async () => {
    setLoading(true);
    setBackendError(null);
    setBackendResponse(null);

    try {
      const response = await apiClient.get<ProtectedResponse>("/api/protected");
      setBackendResponse(response);
    } catch (error) {
      if (error instanceof ApiError) {
        setBackendError(`Backend returned ${error.status}: ${error.body}`);
      } else {
        setBackendError("Failed to connect to backend");
      }
    } finally {
      setLoading(false);
    }
  };

  if (isPending) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-lg">Loading...</div>
      </div>
    );
  }

  if (!session) {
    return null;
  }

  return (
    <main className="p-8 max-w-2xl mx-auto">
      <h1 className="text-2xl font-bold mb-6">IRONMIND Dashboard</h1>

      {/* Session Info */}
      <div className="bg-gray-50 rounded-lg p-4 mb-6">
        <h2 className="font-semibold mb-2">Session Info</h2>
        <p className="text-sm">
          <span className="text-gray-600">Name:</span> {session.user.name || "Not set"}
        </p>
        <p className="text-sm">
          <span className="text-gray-600">Email:</span> {session.user.email}
        </p>
        <p className="text-sm">
          <span className="text-gray-600">User ID:</span>{" "}
          <code className="bg-gray-200 px-1 rounded">{session.user.id}</code>
        </p>
      </div>

      {/* Backend Integration Test */}
      <div className="bg-blue-50 rounded-lg p-4 mb-6">
        <h2 className="font-semibold mb-2">Backend Integration</h2>
        <button
          onClick={testBackendAuth}
          disabled={loading}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {loading ? "Testing..." : "Test Protected Endpoint"}
        </button>

        {backendResponse && (
          <div className="mt-4 p-3 bg-green-100 border border-green-400 rounded">
            <p className="text-green-700 font-medium">Backend Auth Working!</p>
            <p className="text-sm">
              Backend user_id: <code>{backendResponse.user_id}</code>
            </p>
            <p className="text-sm text-gray-600">{backendResponse.message}</p>
          </div>
        )}

        {backendError && (
          <div className="mt-4 p-3 bg-red-100 border border-red-400 rounded">
            <p className="text-red-700 font-medium">Backend Auth Failed</p>
            <p className="text-sm">{backendError}</p>
            <p className="text-xs text-gray-500 mt-2">
              Note: If you see 401, the auth token may not be passing correctly.
              Check browser DevTools Network tab for the Authorization header.
            </p>
          </div>
        )}
      </div>

      {/* Sign Out */}
      <button
        onClick={() => signOut().then(() => router.push("/"))}
        className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
      >
        Sign Out
      </button>
    </main>
  );
}
```

NOTE: If Better Auth doesn't provide a JWT token in the session, we may need to:
1. Create a backend endpoint that exchanges Better Auth session for JWT
2. Or proxy backend requests through Next.js API routes
3. Or use Better Auth's built-in API client features

This will be validated during the human verification checkpoint.
  </action>
  <verify>
    - `cat frontend/lib/api-client.ts` shows fetchWithAuth function
    - `cat frontend/app/dashboard/page.tsx` shows testBackendAuth function
    - `npm run build` in frontend directory succeeds
  </verify>
  <done>API client created with auth token handling. Dashboard updated with backend integration test button that calls /api/protected and displays result.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 authentication and infrastructure:
- Backend: FastAPI with health endpoint, structured logging, JWT validation
- Frontend: Next.js with Better Auth, login/register pages, session management
- Docker Compose: Orchestration for frontend, backend, FalkorDB
- Integration: API client that passes auth tokens to backend
  </what-built>
  <how-to-verify>
1. **Start the stack:**
   ```bash
   cp .env.example .env
   # Generate secret: openssl rand -base64 32
   # Add to .env as AUTH_SECRET=<generated-value>
   docker-compose up --build
   ```

2. **Verify services are healthy:**
   ```bash
   docker-compose ps
   # All services should show "healthy" status
   ```

3. **Test the auth flow:**
   - Open http://localhost:3000 in browser
   - Click "Register"
   - Create account with email/password (min 8 chars)
   - Should redirect to dashboard after registration
   - Dashboard shows session info with user ID

4. **Test backend integration:**
   - On dashboard, click "Test Protected Endpoint"
   - Expected result A: Green success message with backend user_id (auth working)
   - Expected result B: Red error with 401 (auth token not passing - needs investigation)

5. **Verify session persistence:**
   - Refresh the browser (Ctrl+F5)
   - Should still be on dashboard (session persists)

6. **Test logout:**
   - Click "Sign Out"
   - Should return to home page

7. **Test protected endpoint without auth:**
   ```bash
   curl -i http://localhost:8000/api/protected
   # Should return 401 Unauthorized
   ```

8. **Check backend logs:**
   ```bash
   docker-compose logs backend
   # Should show structured JSON logs with request_id
   # Authenticated requests should show user_id
   ```

**If backend auth test fails with 401:**
This indicates Better Auth session tokens aren't compatible with our JWT validation.
We'll need to adjust the approach - note which error you see and we'll fix it.
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe issues encountered:
- If auth token isn't passing: describe what you see in browser DevTools Network tab
- If 401 from backend: provide backend logs showing the error
- If other issues: describe the behavior
  </resume-signal>
</task>

</tasks>

<verification>
Human verification checkpoint validates:
1. Docker Compose orchestrates all services successfully
2. User registration and login work via Better Auth
3. Session persists across browser refresh
4. Backend receives and validates auth tokens
5. Structured logging includes user_id for authenticated requests
6. Unauthenticated requests properly return 401
</verification>

<success_criteria>
- [Human Verified] User can register, login, and session persists
- [Human Verified] Dashboard "Test Protected Endpoint" returns success with user_id
- [Human Verified] Backend logs show user_id for authenticated requests
- [Human Verified] curl without auth to /api/protected returns 401
- [Human Verified] Docker Compose starts all services with healthy status
</success_criteria>

<output>
After completion (including human verification), create `.planning/phases/01-infrastructure-foundation/01-05-SUMMARY.md`
</output>
