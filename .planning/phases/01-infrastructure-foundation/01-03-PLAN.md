---
phase: 01-infrastructure-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/middleware/__init__.py
  - backend/app/middleware/auth.py
  - backend/app/routers/protected.py
  - backend/app/main.py
  - backend/app/config.py
autonomous: true

must_haves:
  truths:
    - "Unauthenticated requests to /api/protected return HTTP 401"
    - "Authenticated requests include user_id in response"
    - "user_id appears in logs for authenticated requests"
    - "JWT validation uses shared secret from environment"
  artifacts:
    - path: "backend/app/middleware/auth.py"
      provides: "JWT validation dependency with user_id extraction"
      exports: ["get_current_user_id"]
    - path: "backend/app/routers/protected.py"
      provides: "Protected test endpoint"
      contains: "Depends(get_current_user_id)"
  key_links:
    - from: "backend/app/routers/protected.py"
      to: "backend/app/middleware/auth.py"
      via: "FastAPI Depends injection"
      pattern: "Depends\\(get_current_user_id\\)"
    - from: "backend/app/middleware/auth.py"
      to: "backend/app/config.py"
      via: "JWT_SECRET_KEY config"
      pattern: "settings\\.JWT_SECRET_KEY"
---

<objective>
Implement backend JWT authentication middleware for protected endpoints.

Purpose: Enable backend to validate authentication tokens from frontend and extract user_id for request tracking. This completes the auth chain: frontend session -> JWT -> backend validation.
Output: FastAPI dependency injection for JWT validation, protected endpoint for testing, user_id logging in authenticated requests.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JWT validation dependency</name>
  <files>
    backend/app/middleware/__init__.py
    backend/app/middleware/auth.py
    backend/app/config.py
  </files>
  <action>
1. Create `backend/app/middleware/__init__.py` (empty, marks as package)

2. Update `backend/app/config.py` to add JWT settings:
```python
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    # Existing
    ENVIRONMENT: str = "development"
    SERVICE_NAME: str = "ironmind-backend"
    LOG_LEVEL: str = "INFO"

    # CORS
    CORS_ORIGINS: str = "http://localhost:3000"

    # JWT Auth
    JWT_SECRET_KEY: str = "your-secret-key-change-in-production"
    JWT_ALGORITHM: str = "HS256"

    @property
    def cors_origins_list(self) -> List[str]:
        return [origin.strip() for origin in self.CORS_ORIGINS.split(",")]

    class Config:
        env_file = ".env"

settings = Settings()
```

3. Create `backend/app/middleware/auth.py` following 01-RESEARCH.md patterns:
```python
from typing import Annotated
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from jwt.exceptions import InvalidTokenError
import structlog

from app.config import settings

security = HTTPBearer()
logger = structlog.get_logger()


async def get_current_user_id(
    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)]
) -> str:
    """
    Validate JWT token and extract user_id.

    Better Auth stores user ID in the 'sub' claim.
    Raises HTTP 401 if token is invalid or missing.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        # Decode JWT token
        payload = jwt.decode(
            credentials.credentials,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM]
        )

        # Better Auth uses 'sub' claim for user ID
        user_id: str = payload.get("sub")
        if user_id is None:
            logger.warning("jwt_missing_sub", payload_keys=list(payload.keys()))
            raise credentials_exception

        # Bind user_id to structlog context for this request
        structlog.contextvars.bind_contextvars(user_id=user_id)
        logger.info("user_authenticated", user_id=user_id)

        return user_id

    except InvalidTokenError as e:
        logger.warning("jwt_validation_failed", error=str(e))
        raise credentials_exception


# Optional: Dependency that makes auth optional (returns None if no token)
async def get_optional_user_id(
    credentials: Annotated[HTTPAuthorizationCredentials | None, Depends(HTTPBearer(auto_error=False))]
) -> str | None:
    """
    Optional authentication - returns user_id if valid token provided, None otherwise.
    """
    if credentials is None:
        return None

    try:
        payload = jwt.decode(
            credentials.credentials,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM]
        )
        user_id = payload.get("sub")
        if user_id:
            structlog.contextvars.bind_contextvars(user_id=user_id)
        return user_id
    except InvalidTokenError:
        return None
```

IMPORTANT: The JWT_SECRET_KEY must match between frontend (Better Auth) and backend. Update .env.example to document this requirement.

4. Update `backend/.env.example` to add:
```
# JWT Authentication (must match BETTER_AUTH_SECRET in frontend)
JWT_SECRET_KEY=your-secret-key-change-in-production
JWT_ALGORITHM=HS256
```
  </action>
  <verify>
    - `cat backend/app/middleware/auth.py` shows get_current_user_id function
    - `cat backend/app/config.py` shows JWT_SECRET_KEY and JWT_ALGORITHM
    - `python -c "from app.middleware.auth import get_current_user_id; print('OK')"` succeeds
  </verify>
  <done>JWT validation dependency created with proper 401 response, user_id extraction from 'sub' claim, and structlog context binding for user_id in logs.</done>
</task>

<task type="auto">
  <name>Task 2: Create protected test endpoint and wire auth</name>
  <files>
    backend/app/routers/protected.py
    backend/app/main.py
  </files>
  <action>
1. Create `backend/app/routers/protected.py`:
```python
from typing import Annotated
from fastapi import APIRouter, Depends
import structlog

from app.middleware.auth import get_current_user_id

router = APIRouter(prefix="/api", tags=["protected"])
logger = structlog.get_logger()


@router.get("/protected")
async def protected_endpoint(
    user_id: Annotated[str, Depends(get_current_user_id)]
):
    """
    Test endpoint that requires authentication.
    Returns user_id to verify auth is working.
    """
    logger.info("protected_endpoint_accessed", user_id=user_id)
    return {
        "message": "You have accessed a protected endpoint",
        "user_id": user_id
    }


@router.get("/me")
async def get_current_user(
    user_id: Annotated[str, Depends(get_current_user_id)]
):
    """
    Returns current user information.
    This endpoint will be expanded when we add user profile data.
    """
    return {
        "user_id": user_id,
        "authenticated": True
    }
```

2. Update `backend/app/main.py` to include protected router:
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from asgi_correlation_id import CorrelationIdMiddleware
import uuid
import time

from app.config import settings
from app.core.logging import configure_logging, get_logger
from app.routers import health, protected  # Add protected import


# Configure logging first
configure_logging(settings.ENVIRONMENT)
logger = get_logger()


# Create FastAPI app
app = FastAPI(
    title="IRONMIND API",
    version="0.1.0",
    description="Technical Document Intelligence API"
)


# Request logging middleware
class RequestLoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        log = get_logger()
        start_time = time.time()
        log.info(
            "request_started",
            path=request.url.path,
            method=request.method
        )

        response = await call_next(request)

        duration_ms = (time.time() - start_time) * 1000
        log.info(
            "request_completed",
            status_code=response.status_code,
            duration_ms=round(duration_ms, 2)
        )
        return response


# Add middleware (order matters: first added = outermost)
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_middleware(
    CorrelationIdMiddleware,
    header_name="X-Request-ID",
    generator=lambda: str(uuid.uuid4())
)

app.add_middleware(RequestLoggingMiddleware)


# Include routers
app.include_router(health.router)
app.include_router(protected.router)  # Add protected router


@app.get("/")
async def root():
    """Root endpoint - basic service info."""
    return {
        "service": "IRONMIND API",
        "version": "0.1.0",
        "status": "running"
    }
```

3. Update CORS to allow Authorization header explicitly (already covered by "*" but explicit is better):
   - The current configuration with allow_credentials=True and allow_headers=["*"] handles Bearer tokens
  </action>
  <verify>
    - `curl http://localhost:8000/api/protected` returns 401 (no token)
    - `curl -H "Authorization: Bearer invalid" http://localhost:8000/api/protected` returns 401 (invalid token)
    - Server logs show "jwt_validation_failed" for invalid token attempts
    - `cat backend/app/main.py | grep protected` shows router included
  </verify>
  <done>Protected endpoints /api/protected and /api/me require authentication. Unauthenticated requests return HTTP 401 with proper WWW-Authenticate header. Auth failures logged with structlog.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Start backend: `cd backend && uvicorn app.main:app --reload`
2. Test unauthenticated: `curl -i http://localhost:8000/api/protected` - expect 401
3. Test invalid token: `curl -i -H "Authorization: Bearer invalid" http://localhost:8000/api/protected` - expect 401
4. Check logs: Should see "jwt_validation_failed" messages
5. Health endpoint still works: `curl http://localhost:8000/health` - expect 200

Note: Full end-to-end testing with valid JWT requires frontend integration (Plan 05).
</verification>

<success_criteria>
- /api/protected returns 401 without Authorization header
- /api/protected returns 401 with invalid Bearer token
- Response includes WWW-Authenticate: Bearer header on 401
- Logs show user_id context when authenticated (to be verified with valid token)
- Logs show jwt_validation_failed for invalid tokens
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-03-SUMMARY.md`
</output>
