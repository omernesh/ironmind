---
phase: 01-infrastructure-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - docker-compose.yml
  - docker-compose.override.yml
  - .env.example
  - backend/.env.example
  - frontend/.env.local.example
  - frontend/lib/auth.ts
autonomous: true

user_setup:
  - service: openai
    why: "LLM and embeddings for RAG (used in later phases, configure now)"
    env_vars:
      - name: OPENAI_API_KEY
        source: "OpenAI Platform -> API Keys -> Create new secret key"
  - service: deepinfra
    why: "Mistral reranking (used in later phases, configure now)"
    env_vars:
      - name: DEEPINFRA_API_KEY
        source: "DeepInfra Dashboard -> API Keys"
  - service: hetzner
    why: "Cloud deployment automation"
    env_vars:
      - name: HETZNER_API_KEY
        source: "Hetzner Cloud Console -> Security -> API Tokens"

must_haves:
  truths:
    - "docker compose up starts all services (frontend, backend, falkordb)"
    - "Frontend accessible at http://localhost:3000"
    - "Backend accessible at http://localhost:8000"
    - "Backend /health returns healthy when all services running"
    - "Frontend can communicate with backend via internal Docker network"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Production Docker Compose configuration"
      contains: ["frontend", "backend", "falkordb"]
    - path: "docker-compose.override.yml"
      provides: "Development overrides (volume mounts, debug mode)"
      contains: "volumes"
    - path: ".env.example"
      provides: "Root environment template with all required variables"
      min_lines: 15
  key_links:
    - from: "docker-compose.yml"
      to: "backend/Dockerfile"
      via: "build context"
      pattern: "build.*backend"
    - from: "docker-compose.yml"
      to: "frontend/Dockerfile"
      via: "build context"
      pattern: "build.*frontend"
    - from: "frontend"
      to: "backend"
      via: "NEXT_PUBLIC_API_URL environment variable"
      pattern: "backend:8000"
---

<objective>
Create Docker Compose orchestration for all services with proper networking and configuration.

Purpose: Enable single-command startup of the entire stack (frontend, backend, FalkorDB) with proper inter-service communication. This is the foundation for local development and cloud deployment.
Output: Working docker-compose.yml that orchestrates all Phase 1 services with shared networking and environment configuration.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create root environment configuration</name>
  <files>
    .env.example
    backend/.env.example
    frontend/.env.local.example
  </files>
  <action>
1. Create `.env.example` (root level, used by docker-compose):
```bash
# IRONMIND Environment Configuration
# Copy this file to .env and fill in your values

# =============================================================================
# SHARED CONFIGURATION
# =============================================================================

# Environment: development | production
ENVIRONMENT=development

# Shared secret for JWT validation (MUST match between frontend and backend)
# Generate with: openssl rand -base64 32
AUTH_SECRET=your-secret-key-generate-with-openssl-rand-base64-32

# =============================================================================
# FRONTEND (Next.js)
# =============================================================================

# Public URL for the frontend application
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Backend API URL (use service name in Docker, localhost for local dev)
NEXT_PUBLIC_API_URL=http://localhost:8000

# =============================================================================
# BACKEND (FastAPI)
# =============================================================================

# Service name for logging
SERVICE_NAME=ironmind-backend

# Log level: DEBUG | INFO | WARNING | ERROR
LOG_LEVEL=INFO

# CORS allowed origins (comma-separated)
CORS_ORIGINS=http://localhost:3000

# JWT configuration
JWT_SECRET_KEY=${AUTH_SECRET}
JWT_ALGORITHM=HS256

# =============================================================================
# DATABASE (FalkorDB)
# =============================================================================

# FalkorDB connection (Redis protocol)
FALKORDB_URL=redis://falkordb:6379
FALKORDB_PASSWORD=

# =============================================================================
# EXTERNAL SERVICES (Configure when needed)
# =============================================================================

# OpenAI - for embeddings and LLM
OPENAI_API_KEY=sk-your-openai-api-key

# DeepInfra - for Mistral reranking
DEEPINFRA_API_KEY=your-deepinfra-api-key

# Hetzner - for cloud deployment
HETZNER_API_KEY=your-hetzner-api-key

# Mailgun - for email (Better Auth verification)
MAILGUN_SMTP_LOGIN=
MAILGUN_SMTP_PASSWORD=
MAIL_FROM=noreply@ironmind.chat
```

2. Update `backend/.env.example` to reference root config:
```bash
# Backend-specific environment configuration
# For Docker: These are set via docker-compose.yml from root .env
# For local development: Copy to .env and configure

ENVIRONMENT=development
SERVICE_NAME=ironmind-backend
LOG_LEVEL=INFO

# CORS (comma-separated origins)
CORS_ORIGINS=http://localhost:3000

# JWT Auth (must match AUTH_SECRET in frontend)
JWT_SECRET_KEY=your-secret-key-change-in-production
JWT_ALGORITHM=HS256

# Database (FalkorDB)
FALKORDB_URL=redis://localhost:6379
FALKORDB_PASSWORD=

# OpenAI
OPENAI_API_KEY=sk-your-openai-api-key

# DeepInfra (Mistral reranking)
DEEPINFRA_API_KEY=your-deepinfra-api-key
```

3. Update `frontend/.env.local.example`:
```bash
# Frontend-specific environment configuration
# For Docker: These are set via docker-compose.yml from root .env
# For local development: Copy to .env.local and configure

# Public URL
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Backend API URL
# - Local dev: http://localhost:8000
# - Docker: http://backend:8000 (set via docker-compose)
NEXT_PUBLIC_API_URL=http://localhost:8000

# Better Auth secret (must match JWT_SECRET_KEY in backend)
BETTER_AUTH_SECRET=your-secret-key-change-in-production
```
  </action>
  <verify>
    - `cat .env.example` shows all configuration sections
    - All three .env files exist and are consistent
    - AUTH_SECRET / BETTER_AUTH_SECRET / JWT_SECRET_KEY documented to match
  </verify>
  <done>Root .env.example created with all environment variables. Backend and frontend .env files updated to reference shared AUTH_SECRET. Documentation notes that secrets must match between services.</done>
</task>

<task type="auto">
  <name>Task 2: Create Docker Compose configuration</name>
  <files>
    docker-compose.yml
    docker-compose.override.yml
  </files>
  <action>
1. Create `docker-compose.yml` (production configuration):
```yaml
version: '3.8'

services:
  # ==========================================================================
  # Frontend (Next.js with Better Auth)
  # ==========================================================================
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_APP_URL=${NEXT_PUBLIC_APP_URL:-http://localhost:3000}
      - NEXT_PUBLIC_API_URL=http://backend:8000
      - BETTER_AUTH_SECRET=${AUTH_SECRET}
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    networks:
      - ironmind-network

  # ==========================================================================
  # Backend (FastAPI)
  # ==========================================================================
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - ENVIRONMENT=${ENVIRONMENT:-production}
      - SERVICE_NAME=${SERVICE_NAME:-ironmind-backend}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      - CORS_ORIGINS=${CORS_ORIGINS:-http://localhost:3000}
      - JWT_SECRET_KEY=${AUTH_SECRET}
      - JWT_ALGORITHM=${JWT_ALGORITHM:-HS256}
      - FALKORDB_URL=redis://falkordb:6379
      - FALKORDB_PASSWORD=${FALKORDB_PASSWORD:-}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - DEEPINFRA_API_KEY=${DEEPINFRA_API_KEY}
    depends_on:
      falkordb:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    volumes:
      - backend-data:/app/data
    networks:
      - ironmind-network

  # ==========================================================================
  # FalkorDB (Graph Database with Vector Support)
  # ==========================================================================
  falkordb:
    image: falkordb/falkordb:latest
    ports:
      - "6379:6379"
    environment:
      - REDIS_ARGS=--requirepass ${FALKORDB_PASSWORD:-}
    volumes:
      - falkordb-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - ironmind-network

  # ==========================================================================
  # Docling Serve (Document Processing) - Added for future phases
  # ==========================================================================
  # docling:
  #   image: ds4sd/docling-serve:latest
  #   ports:
  #     - "5000:5000"
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 60s
  #   networks:
  #     - ironmind-network

volumes:
  falkordb-data:
    driver: local
  backend-data:
    driver: local

networks:
  ironmind-network:
    driver: bridge
```

2. Create `docker-compose.override.yml` (development overrides):
```yaml
# Development overrides - automatically loaded by docker-compose
# For production, use: docker-compose -f docker-compose.yml up

version: '3.8'

services:
  frontend:
    build:
      target: deps  # Use deps stage for faster rebuilds
    volumes:
      - ./frontend:/app
      - /app/node_modules
      - /app/.next
    environment:
      - NODE_ENV=development
    command: npm run dev

  backend:
    volumes:
      - ./backend:/app
    environment:
      - ENVIRONMENT=development
      - LOG_LEVEL=DEBUG
    command: uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

IMPORTANT notes for Docker Compose:
- Services communicate via service names (backend, falkordb), not localhost
- Frontend NEXT_PUBLIC_API_URL is set to http://backend:8000 for internal Docker communication
- External access (browser) still uses localhost:3000 and localhost:8000
- FalkorDB uses Redis protocol on port 6379
- Docling-serve is commented out - will be enabled in Phase 2
  </action>
  <verify>
    - `cat docker-compose.yml` shows frontend, backend, falkordb services
    - `cat docker-compose.override.yml` shows volume mounts for development
    - `docker-compose config` validates configuration (no errors)
  </verify>
  <done>Docker Compose configuration created with production and development modes. Services use named network for communication. Health checks configured for all services. FalkorDB included for Phase 4 knowledge graph.</done>
</task>

<task type="auto">
  <name>Task 3: Update frontend auth to work with shared secret</name>
  <files>
    frontend/lib/auth.ts
  </files>
  <action>
Update `frontend/lib/auth.ts` to use environment variables for the secret:

```typescript
import { betterAuth } from "better-auth";
import Database from "better-sqlite3";

// Database path - use /app/data in Docker, local path otherwise
const dbPath = process.env.DATABASE_PATH || "./auth.db";

export const auth = betterAuth({
  database: new Database(dbPath),
  secret: process.env.BETTER_AUTH_SECRET,  // Shared secret for JWT signing
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: false,  // Disable for POC speed
    minPasswordLength: 8,
  },
  session: {
    expiresIn: 60 * 60 * 24 * 7,  // 7 days
    updateAge: 60 * 60 * 24,  // Update session every 24 hours
    cookieCache: {
      enabled: true,
      maxAge: 60 * 5,  // 5 minute cookie cache
    },
  },
  trustedOrigins: [
    process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000",
  ],
});

// Export auth type for use in other files
export type Auth = typeof auth;
```

IMPORTANT: Better Auth's session mechanism may not use standard JWT by default. If backend JWT validation fails, we may need to:
1. Configure Better Auth to issue JWT tokens explicitly
2. Or create a separate endpoint in frontend that issues JWT for backend communication
3. Or use session-based auth where frontend forwards session cookie to backend

For POC simplicity, we'll verify this works and adjust in integration testing.
  </action>
  <verify>
    - `cat frontend/lib/auth.ts` shows `secret: process.env.BETTER_AUTH_SECRET`
    - `cat frontend/lib/auth.ts` shows configurable DATABASE_PATH
  </verify>
  <done>Frontend auth configuration updated to use shared secret from environment. Database path configurable for Docker deployment.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Copy .env.example to .env: `cp .env.example .env`
2. Generate secret: `openssl rand -base64 32` and add to .env as AUTH_SECRET
3. Start services: `docker-compose up --build`
4. Wait for health checks to pass (check with `docker-compose ps`)
5. Test frontend: http://localhost:3000 - landing page loads
6. Test backend: http://localhost:8000/health - returns {"status": "healthy"}
7. Test FalkorDB: `docker-compose exec falkordb redis-cli ping` - returns PONG
8. Register user at http://localhost:3000/register - should succeed
9. Check logs: `docker-compose logs backend` - structured JSON with request_id
</verification>

<success_criteria>
- `docker-compose up` starts all services without errors
- Frontend accessible at http://localhost:3000
- Backend health check at http://localhost:8000/health returns {"status": "healthy"}
- FalkorDB responds to ping
- All services on same Docker network (ironmind-network)
- Environment variables properly passed from root .env
- Development override enables hot reload for frontend and backend
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-04-SUMMARY.md`
</output>
