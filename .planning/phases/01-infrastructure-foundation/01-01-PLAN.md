---
phase: 01-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/__init__.py
  - backend/app/main.py
  - backend/app/config.py
  - backend/app/core/__init__.py
  - backend/app/core/logging.py
  - backend/app/routers/__init__.py
  - backend/app/routers/health.py
  - backend/requirements.txt
  - backend/Dockerfile
  - backend/.env.example
autonomous: true

must_haves:
  truths:
    - "GET /health returns JSON with status healthy"
    - "All backend log output is structured JSON with timestamp, level, service name"
    - "Each request generates unique request_id visible in logs"
    - "Request path, method logged on entry; status_code, duration logged on exit"
  artifacts:
    - path: "backend/app/main.py"
      provides: "FastAPI application initialization with CORS and middleware"
      min_lines: 40
    - path: "backend/app/core/logging.py"
      provides: "Structlog configuration with JSON rendering and correlation ID support"
      exports: ["configure_logging", "get_logger"]
    - path: "backend/app/routers/health.py"
      provides: "Health check endpoint"
      contains: "@router.get"
    - path: "backend/Dockerfile"
      provides: "Production Docker image with Python 3.11-slim"
      contains: "python:3.11-slim"
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/core/logging.py"
      via: "configure_logging() called at startup"
      pattern: "configure_logging"
    - from: "backend/app/main.py"
      to: "backend/app/routers/health.py"
      via: "router included in app"
      pattern: "include_router.*health"
---

<objective>
Create the foundational backend structure with FastAPI, structured logging, and health endpoint.

Purpose: Establish the backend skeleton that all subsequent plans will build upon. Proper logging from day 1 enables debugging throughout development.
Output: Working FastAPI backend with /health endpoint, structured JSON logging with request correlation, and production-ready Dockerfile.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend project structure with FastAPI skeleton</name>
  <files>
    backend/app/__init__.py
    backend/app/main.py
    backend/app/config.py
    backend/app/core/__init__.py
    backend/app/routers/__init__.py
    backend/requirements.txt
    backend/.env.example
  </files>
  <action>
Create the backend directory structure following the pattern from 01-RESEARCH.md:

1. Create `backend/app/__init__.py` (empty, marks as package)

2. Create `backend/app/config.py` with pydantic-settings:
   - Settings class with fields: ENVIRONMENT (default "development"), SERVICE_NAME (default "ironmind-backend"), LOG_LEVEL (default "INFO")
   - Load from environment variables
   - Export `settings` singleton

3. Create `backend/app/main.py`:
   - Initialize FastAPI with title="IRONMIND API", version="0.1.0"
   - Add CORSMiddleware with configurable origins (default ["http://localhost:3000"])
   - Import and call configure_logging() from core.logging (will be created in Task 2)
   - Leave placeholder comment for health router (added in Task 3)
   - Create simple root endpoint returning {"service": "IRONMIND API", "status": "running"}

4. Create `backend/app/core/__init__.py` (empty)
5. Create `backend/app/routers/__init__.py` (empty)

6. Create `backend/requirements.txt`:
   - fastapi[standard]>=0.109.0
   - uvicorn[standard]>=0.27.0
   - gunicorn>=21.0.0
   - pydantic-settings>=2.0.0
   - structlog>=24.1.0
   - asgi-correlation-id>=4.3.0
   - pyjwt>=2.8.0
   - python-dotenv>=1.0.0

7. Create `backend/.env.example`:
   - ENVIRONMENT=development
   - SERVICE_NAME=ironmind-backend
   - LOG_LEVEL=INFO
   - JWT_SECRET_KEY=your-secret-key-change-in-production
   - CORS_ORIGINS=http://localhost:3000

Use absolute imports (from app.config import settings, not relative imports).
  </action>
  <verify>
    - `ls backend/app/` shows __init__.py, main.py, config.py, core/, routers/
    - `cat backend/requirements.txt` shows all required packages
    - `cat backend/.env.example` shows all environment variables
  </verify>
  <done>Backend directory structure exists with FastAPI skeleton, requirements.txt lists all dependencies, .env.example documents all configuration.</done>
</task>

<task type="auto">
  <name>Task 2: Configure structured JSON logging with request correlation</name>
  <files>
    backend/app/core/logging.py
    backend/app/main.py
  </files>
  <action>
Create structured logging configuration following 01-RESEARCH.md patterns:

1. Create `backend/app/core/logging.py`:
   - Import structlog, asgi_correlation_id, logging
   - Create `configure_logging(environment: str = "production")` function:
     - Build processors list: merge_contextvars, add_log_level, TimeStamper(fmt="iso")
     - If environment == "development": add ConsoleRenderer()
     - Else: add JSONRenderer()
     - Call structlog.configure() with processors, PrintLoggerFactory()
   - Create `get_logger()` function returning structlog.get_logger()

2. Update `backend/app/main.py`:
   - Import configure_logging from app.core.logging
   - Import CorrelationIdMiddleware from asgi_correlation_id
   - Import uuid for correlation ID generation
   - Call configure_logging(settings.ENVIRONMENT) after app creation
   - Add CorrelationIdMiddleware with header_name="X-Request-ID", generator=lambda: str(uuid.uuid4())
   - Create request logging middleware that:
     - Logs "request_started" with path, method on entry
     - Logs "request_completed" with status_code, duration_ms on exit
     - Uses time.time() for duration calculation

IMPORTANT: Do not use @app.middleware("http") decorator for the logging middleware - use a proper ASGI middleware class or Starlette's BaseHTTPMiddleware to avoid issues with async context.

Example middleware pattern:
```python
from starlette.middleware.base import BaseHTTPMiddleware
import time

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        logger = get_logger()
        start_time = time.time()
        logger.info("request_started", path=request.url.path, method=request.method)
        response = await call_next(request)
        duration_ms = (time.time() - start_time) * 1000
        logger.info("request_completed", status_code=response.status_code, duration_ms=round(duration_ms, 2))
        return response
```

Add middleware in correct order: CORSMiddleware first, then CorrelationIdMiddleware, then RequestLoggingMiddleware.
  </action>
  <verify>
    - `cat backend/app/core/logging.py` shows configure_logging and get_logger functions
    - `cat backend/app/main.py` shows middleware configuration
    - Run `cd backend && pip install -r requirements.txt && python -c "from app.main import app; print('OK')"` succeeds
  </verify>
  <done>Structlog configured for JSON output in production, console in development. Request correlation middleware generates X-Request-ID headers. Request/response logging captures path, method, status_code, duration_ms.</done>
</task>

<task type="auto">
  <name>Task 3: Add health endpoint and create Dockerfile</name>
  <files>
    backend/app/routers/health.py
    backend/app/main.py
    backend/Dockerfile
  </files>
  <action>
1. Create `backend/app/routers/health.py`:
   - Import APIRouter from fastapi
   - Create router = APIRouter(prefix="/health", tags=["health"])
   - Create GET "/" endpoint returning {"status": "healthy"}
   - Add docstring: "Liveness probe - basic app health"

2. Update `backend/app/main.py`:
   - Import health router from app.routers.health
   - Add app.include_router(health.router) after middleware setup

3. Create `backend/Dockerfile` following 01-RESEARCH.md patterns:
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install dependencies first for caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY app/ ./app/

# Create non-root user for security
RUN useradd --create-home appuser
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run with Gunicorn + Uvicorn workers
CMD ["gunicorn", "app.main:app", "-w", "2", "-k", "uvicorn.workers.UvicornWorker", "-b", "0.0.0.0:8000"]
```

Note: The Dockerfile uses curl for healthcheck which requires installing curl. Add this after the base image:
```dockerfile
RUN apt-get update && apt-get install -y --no-install-recommends curl && rm -rf /var/lib/apt/lists/*
```
  </action>
  <verify>
    - `curl http://localhost:8000/health` returns {"status":"healthy"} (after running uvicorn)
    - `cat backend/Dockerfile` shows python:3.11-slim base image
    - `docker build -t ironmind-backend ./backend` succeeds
  </verify>
  <done>Health endpoint at GET /health returns JSON status. Dockerfile builds with Python 3.11-slim, non-root user, and healthcheck configured.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Start backend: `cd backend && pip install -r requirements.txt && uvicorn app.main:app --reload`
2. Test health: `curl -i http://localhost:8000/health` - expect 200 with {"status":"healthy"}
3. Check logs: Console should show structured output with request_id, timestamp, path, method
4. Verify request_id: Response headers should include X-Request-ID
5. Build Docker: `docker build -t ironmind-backend ./backend` - expect success
</verification>

<success_criteria>
- GET /health returns 200 with {"status": "healthy"}
- All logs are structured JSON (in production mode) or formatted console (in development)
- Every request gets unique request_id in X-Request-ID header
- Request entry logged with path, method
- Response logged with status_code, duration_ms
- Docker build succeeds with python:3.11-slim base
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md`
</output>
