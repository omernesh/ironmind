---
phase: 04-knowledge-graph-integration
plan: 05
type: execute
wave: 4
depends_on: ["04-03", "04-04"]
files_modified:
  - backend/app/routers/debug.py
  - backend/app/main.py
  - backend/tests/test_graph.py
autonomous: false

must_haves:
  truths:
    - "Debug endpoint returns subgraph for specified entity"
    - "Graph data is populated during document ingestion"
    - "Graph-aware retrieval improves answers for relationship queries"
  artifacts:
    - path: "backend/app/routers/debug.py"
      provides: "GET /api/debug/graph/sample endpoint"
      exports: ["router"]
    - path: "backend/tests/test_graph.py"
      provides: "Integration tests for graph functionality"
      min_lines: 50
  key_links:
    - from: "backend/app/routers/debug.py"
      to: "backend/app/services/graph/graph_store.py"
      via: "Subgraph query"
      pattern: "graph_store\\.get_subgraph"
    - from: "backend/app/main.py"
      to: "backend/app/routers/debug.py"
      via: "Router registration"
      pattern: "include_router.*debug"
---

<objective>
Create debug endpoint for graph inspection and verify end-to-end graph integration.

Purpose: Implement KG-06 (debug endpoint GET /api/debug/graph/sample) for graph inspection, add integration tests, and verify the complete flow from ingestion through graph-enhanced retrieval.

Output: Working debug endpoint, integration tests, verified graph-aware RAG pipeline.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-knowledge-graph-integration/04-CONTEXT.md
@.planning/phases/04-knowledge-graph-integration/04-03-SUMMARY.md
@.planning/phases/04-knowledge-graph-integration/04-04-SUMMARY.md
@backend/app/main.py
@backend/app/services/graph/graph_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create debug router with graph sample endpoint</name>
  <files>backend/app/routers/debug.py, backend/app/main.py</files>
  <action>
    Create backend/app/routers/debug.py with graph inspection endpoint:

    1. Define router:
       router = APIRouter(prefix="/api/debug", tags=["debug"])

    2. Create GET /graph/sample endpoint:
       @router.get("/graph/sample")
       async def get_graph_sample(
           entity: str = Query(..., description="Entity name to center subgraph on"),
           format: str = Query("edgelist", description="Output format: edgelist or cytoscape"),
           depth: int = Query(2, ge=1, le=3, description="Traversal depth"),
           user_id: str = Depends(get_current_user_id)
       ):
           """
           Return subgraph centered on specified entity.

           Used for debugging graph population and retrieval.
           Formats:
           - edgelist: Simple JSON [{from, to, relationship, context}]
           - cytoscape: Cytoscape.js format for visualization
           """
           graph_store = GraphStore()
           subgraph = graph_store.get_subgraph(entity, user_id, depth)

           if format == "cytoscape":
               return format_cytoscape(subgraph)
           else:
               return format_edgelist(subgraph)

    3. Add format_edgelist(subgraph: dict) -> dict:
       - Extract edges from subgraph
       - Return {"edges": [{"from": ..., "to": ..., "relationship": ..., "context": ...}]}

    4. Add format_cytoscape(subgraph: dict) -> dict:
       - Convert to Cytoscape.js elements format
       - nodes: [{"data": {"id": name, "label": name, "type": entity_type}}]
       - edges: [{"data": {"source": from, "target": to, "label": relationship_type}}]
       - Return {"elements": {"nodes": [...], "edges": [...]}}

    5. Add GET /graph/stats endpoint:
       @router.get("/graph/stats")
       async def get_graph_stats(user_id: str = Depends(get_current_user_id)):
           """Return graph statistics for current user."""
           graph_store = GraphStore()
           return {
               "entity_count": graph_store.count_entities(user_id),
               "relationship_count": graph_store.count_relationships(user_id),
               "entity_types": graph_store.get_entity_type_counts(user_id)
           }

    6. Update main.py to include debug router:
       from app.routers import debug
       app.include_router(debug.router)
  </action>
  <verify>
    # Start services and test endpoint
    curl -H "Authorization: Bearer $TOKEN" \
      "http://localhost:8000/api/debug/graph/sample?entity=GPS&format=edgelist"
  </verify>
  <done>GET /api/debug/graph/sample endpoint returns subgraph in edgelist or cytoscape format.</done>
</task>

<task type="auto">
  <name>Task 2: Add GraphStore helper methods for stats</name>
  <files>backend/app/services/graph/graph_store.py</files>
  <action>
    Add methods to GraphStore for the stats endpoint:

    1. count_entities(self, user_id: str) -> int:
       query = "MATCH (e:Entity {user_id: $user_id}) RETURN count(e) as count"
       Return count from result

    2. count_relationships(self, user_id: str) -> int:
       query = "MATCH (a:Entity {user_id: $user_id})-[r]->(b) RETURN count(r) as count"
       Return count from result

    3. get_entity_type_counts(self, user_id: str) -> dict:
       query = """
       MATCH (e:Entity {user_id: $user_id})
       RETURN e.type as type, count(*) as count
       """
       Return {type: count, ...} dict

    4. list_entities(self, user_id: str, entity_type: str = None, limit: int = 100) -> List[dict]:
       - Query entities for user, optionally filtered by type
       - Return list of entity dicts
       - Used for browsing/debugging
  </action>
  <verify>
    python -c "
    from app.services.graph.graph_store import GraphStore
    store = GraphStore()
    count = store.count_entities('test_user')
    print(f'Entity count: {count}')
    "
  </verify>
  <done>GraphStore provides statistics methods for debug endpoint.</done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for graph functionality</name>
  <files>backend/tests/test_graph.py</files>
  <action>
    Create comprehensive integration tests:

    1. Test schema validation:
       - Entity with valid type succeeds
       - Entity with invalid type raises ValidationError
       - Relationship with valid type succeeds
       - Relationship with invalid type raises ValidationError

    2. Test GraphStore CRUD:
       - add_entity creates node in FalkorDB
       - get_entity retrieves correct entity
       - add_relationship creates edge
       - get_subgraph returns connected nodes
       - delete_document_entities removes all entities for doc

    3. Test EntityExtractor:
       - extract_from_chunk returns GraphExtraction
       - Entities have correct types (in allowed set)
       - Relationships have context populated
       - Batch extraction handles multiple chunks

    4. Test GraphRetriever:
       - is_relationship_query detects relationship patterns
       - extract_query_entities finds entities in query
       - retrieve_graph_context returns graph-derived chunks

    5. Test pipeline integration (requires Docker):
       - Mark with @pytest.mark.integration
       - Upload test document
       - Verify entities created in graph
       - Query via chat endpoint
       - Verify graph context in response

    Use pytest fixtures for GraphStore and EntityExtractor initialization.
    Mock OpenAI calls in unit tests, use real calls only in integration tests.
  </action>
  <verify>
    cd backend && python -m pytest tests/test_graph.py -v
  </verify>
  <done>Integration tests verify graph schemas, CRUD, extraction, and retrieval.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete knowledge graph integration:
    1. Entity/relationship extraction from document chunks
    2. FalkorDB storage during document ingestion
    3. Graph-aware retrieval for relationship queries
    4. Debug endpoint for graph inspection
  </what-built>
  <how-to-verify>
    1. Start all services:
       docker-compose up -d

    2. Upload a test document via the documents API:
       curl -X POST http://localhost:8000/api/documents \
         -H "Authorization: Bearer $TOKEN" \
         -F "file=@test_document.pdf"

    3. Wait for processing to complete, check logs for:
       - graph_extraction_completed event
       - Entity and relationship counts

    4. Check graph contents via debug endpoint:
       curl "http://localhost:8000/api/debug/graph/sample?entity=SomeEntity&format=edgelist" \
         -H "Authorization: Bearer $TOKEN"

    5. Ask a relationship question via chat:
       curl -X POST http://localhost:8000/api/chat \
         -H "Authorization: Bearer $TOKEN" \
         -H "Content-Type: application/json" \
         -d '{"question": "How does X connect to Y?"}'

    6. Verify response includes graph-derived context (check citations for source="graph")

    Expected behavior:
    - Document ingestion creates entities in FalkorDB
    - Debug endpoint returns subgraph with nodes and edges
    - Relationship queries return enhanced answers with graph context
    - Entity types are restricted to hardware/software/configuration/error
  </how-to-verify>
  <resume-signal>Type "approved" if graph integration works correctly, or describe issues.</resume-signal>
</task>

</tasks>

<verification>
1. Debug endpoint: GET /api/debug/graph/sample?entity=X returns subgraph data
2. Format options: format=edgelist and format=cytoscape both work
3. Stats endpoint: GET /api/debug/graph/stats returns entity/relationship counts
4. Auth required: Unauthenticated requests to debug endpoints return 401
5. User isolation: Debug endpoints only return current user's graph data
6. Integration tests: pytest tests/test_graph.py passes
</verification>

<success_criteria>
- GET /api/debug/graph/sample endpoint returns subgraph centered on queried entity
- Both edgelist and cytoscape formats produce valid JSON
- Graph contains entities from ingested documents
- Entity types are constrained (hardware, software, configuration, error only)
- Relationship queries show improved context from graph expansion
- All graph endpoints require authentication and filter by user_id
- Integration tests pass for schema, CRUD, extraction, and retrieval
</success_criteria>

<output>
After completion, create `.planning/phases/04-knowledge-graph-integration/04-05-SUMMARY.md`
</output>
