---
phase: 04-knowledge-graph-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/graph/__init__.py
  - backend/app/services/graph/schemas.py
  - backend/app/services/graph/graph_store.py
  - backend/app/config.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "FalkorDB client can connect and execute queries"
    - "Entity and Relationship schemas enforce type constraints"
    - "Graph operations (create node, create edge, query) work correctly"
  artifacts:
    - path: "backend/app/services/graph/schemas.py"
      provides: "Pydantic schemas for Entity, Relationship, GraphExtraction"
      exports: ["Entity", "Relationship", "GraphExtraction"]
    - path: "backend/app/services/graph/graph_store.py"
      provides: "FalkorDB client wrapper with CRUD operations"
      exports: ["GraphStore"]
    - path: "backend/app/config.py"
      provides: "FalkorDB configuration settings"
      contains: "FALKORDB_URL"
  key_links:
    - from: "backend/app/services/graph/graph_store.py"
      to: "falkordb"
      via: "FalkorDB Python client"
      pattern: "FalkorDB|falkordb"
    - from: "backend/app/services/graph/schemas.py"
      to: "pydantic"
      via: "Pydantic BaseModel"
      pattern: "BaseModel|Literal"
---

<objective>
Create Pydantic schemas for entity/relationship extraction and FalkorDB client wrapper for graph storage.

Purpose: Establish foundational data models and database connectivity that entity extraction and graph retrieval services will build upon. The schemas enforce consistent entity types (hardware, software, configuration, error) and relationship types (depends_on, configures, connects_to, is_part_of) as decided in CONTEXT.md.

Output: Validated graph schemas, working FalkorDB client, extended configuration.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-knowledge-graph-integration/04-CONTEXT.md
@.planning/phases/04-knowledge-graph-integration/04-RESEARCH.md
@backend/app/config.py
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add falkordb dependency and configuration</name>
  <files>backend/requirements.txt, backend/app/config.py</files>
  <action>
    Add falkordb>=1.4.0 to requirements.txt (Python client for FalkorDB).

    Extend Settings class in config.py with FalkorDB settings:
    - FALKORDB_URL: str = "redis://falkordb:6379" (Docker service)
    - FALKORDB_GRAPH_NAME: str = "aerospace_kb" (graph database name)
    - GRAPH_TRAVERSAL_DEPTH: int = 2 (max hops for queries)
    - ENTITY_SIMILARITY_THRESHOLD: float = 0.85 (for resolution)

    Note: FALKORDB_URL is already referenced in docker-compose.yml environment.
  </action>
  <verify>
    pip install falkordb>=1.4.0 completes successfully.
    from app.config import settings; print(settings.FALKORDB_URL) outputs redis://falkordb:6379.
  </verify>
  <done>FalkorDB dependency installed, configuration extended with graph settings.</done>
</task>

<task type="auto">
  <name>Task 2: Create Pydantic schemas for entities and relationships</name>
  <files>backend/app/services/graph/__init__.py, backend/app/services/graph/schemas.py</files>
  <action>
    Create backend/app/services/graph/ directory structure.

    In schemas.py, define:

    1. Entity schema with Literal type constraint:
       - name: str (entity name, e.g., "GPS Module")
       - type: Literal["hardware", "software", "configuration", "error"] (strict types from CONTEXT.md)
       - description: str (brief description from document)
       - parent_entity: Optional[str] = None (for hierarchical extraction)
       - doc_id: str (source document)
       - chunk_id: str (source chunk for traceability)

    2. Relationship schema:
       - source_entity: str (entity name)
       - target_entity: str (entity name)
       - relationship_type: Literal["depends_on", "configures", "connects_to", "is_part_of"]
       - context: str (sentence describing relationship for LLM grounding)
       - doc_id: str (source document)

    3. GraphExtraction schema (for LLM output):
       - entities: List[Entity]
       - relationships: List[Relationship]

    Use Pydantic v2 syntax (model_validator, Field with examples).
    Include docstrings explaining each field per CONTEXT.md decisions.

    In __init__.py, export: Entity, Relationship, GraphExtraction.
  </action>
  <verify>
    from app.services.graph.schemas import Entity, Relationship, GraphExtraction
    Entity(name="GPS", type="hardware", description="Receiver", parent_entity=None, doc_id="d1", chunk_id="c1")
    # Fails on invalid type:
    Entity(name="X", type="invalid", ...)  # ValidationError
  </verify>
  <done>Pydantic schemas enforce entity types (hardware/software/configuration/error) and relationship types (depends_on/configures/connects_to/is_part_of).</done>
</task>

<task type="auto">
  <name>Task 3: Create FalkorDB client wrapper</name>
  <files>backend/app/services/graph/graph_store.py</files>
  <action>
    Create GraphStore class that wraps FalkorDB Python client:

    1. __init__(self): Connect to FalkorDB using settings.FALKORDB_URL and select graph settings.FALKORDB_GRAPH_NAME.

    2. ensure_indexes(self): Create indexes on entity properties for query performance:
       - CREATE INDEX ON :Entity(name)
       - CREATE INDEX ON :Entity(type)
       - CREATE INDEX ON :Entity(user_id)
       Run once during initialization.

    3. add_entity(self, entity: Entity, user_id: str) -> bool:
       - MERGE on entity name + user_id (prevents duplicates)
       - Set properties: name, type, description, parent_entity, doc_id, chunk_id, user_id
       - Use parameterized queries for safety

    4. add_relationship(self, rel: Relationship, user_id: str) -> bool:
       - MATCH source and target entities (filtered by user_id)
       - CREATE relationship with type and context property
       - Handle case where source/target don't exist (log warning, skip)

    5. get_entity(self, name: str, user_id: str) -> Optional[dict]:
       - MATCH (e:Entity {name: $name, user_id: $user_id}) RETURN e

    6. get_subgraph(self, entity_name: str, user_id: str, depth: int = 2, limit: int = 50) -> dict:
       - BFS traversal with depth limit (CONTEXT.md: configurable depth)
       - Returns {"nodes": [...], "edges": [...]} format
       - Query: MATCH path = (start:Entity {name: $name, user_id: $user_id})-[*0..N]-(connected)
       - Include LIMIT to prevent explosion

    7. delete_document_entities(self, doc_id: str, user_id: str) -> int:
       - Delete all entities/relationships from specific document (for re-ingestion)
       - MATCH (e:Entity {doc_id: $doc_id, user_id: $user_id}) DETACH DELETE e

    Use structlog for logging (import from app.core.logging).
    Handle connection errors gracefully with descriptive messages.

    IMPORTANT: FalkorDB uses Cypher syntax similar to Neo4j. Use MERGE for upsert, parameterized queries ($name) for values.
  </action>
  <verify>
    Start FalkorDB: docker-compose up falkordb -d
    from app.services.graph.graph_store import GraphStore
    store = GraphStore()
    store.add_entity(Entity(name="GPS", type="hardware", description="test", doc_id="d1", chunk_id="c1"), "user1")
    result = store.get_entity("GPS", "user1")
    assert result["name"] == "GPS"
  </verify>
  <done>FalkorDB client wrapper supports entity/relationship CRUD, subgraph traversal, and document cleanup.</done>
</task>

</tasks>

<verification>
1. FalkorDB connection: docker-compose up falkordb -d && python -c "from app.services.graph.graph_store import GraphStore; GraphStore()"
2. Schema validation: python -c "from app.services.graph.schemas import Entity; Entity(name='X', type='invalid', description='', doc_id='', chunk_id='')" should fail with ValidationError
3. Entity CRUD: Add entity, retrieve it, verify properties match
4. Subgraph query: Add 3 connected entities, query subgraph, verify all 3 returned
</verification>

<success_criteria>
- FalkorDB client connects to falkordb:6379 Docker service
- Entity schema rejects invalid types (only hardware/software/configuration/error allowed)
- Relationship schema rejects invalid types (only depends_on/configures/connects_to/is_part_of)
- GraphStore.add_entity() creates nodes with user_id isolation
- GraphStore.get_subgraph() returns connected nodes within depth limit
- All operations use parameterized queries (no string interpolation in Cypher)
</success_criteria>

<output>
After completion, create `.planning/phases/04-knowledge-graph-integration/04-01-SUMMARY.md`
</output>
