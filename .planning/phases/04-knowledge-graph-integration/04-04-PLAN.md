---
phase: 04-knowledge-graph-integration
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - backend/app/services/graph/graph_retriever.py
  - backend/app/services/graph/__init__.py
  - backend/app/services/retriever.py
  - backend/app/routers/chat.py
autonomous: true

must_haves:
  truths:
    - "Graph retriever extracts entities from query and expands via graph traversal"
    - "Dual-channel retrieval merges hybrid search results with graph-connected entities"
    - "Chat endpoint uses enhanced retrieval for relationship-based questions"
  artifacts:
    - path: "backend/app/services/graph/graph_retriever.py"
      provides: "Graph-aware retrieval with subgraph expansion"
      exports: ["GraphRetriever"]
    - path: "backend/app/services/retriever.py"
      provides: "Enhanced retriever with graph integration"
      contains: "GraphRetriever|graph_retriever"
  key_links:
    - from: "backend/app/services/graph/graph_retriever.py"
      to: "backend/app/services/graph/graph_store.py"
      via: "Subgraph traversal"
      pattern: "graph_store\\.get_subgraph"
    - from: "backend/app/services/retriever.py"
      to: "backend/app/services/graph/graph_retriever.py"
      via: "Dual-channel merge"
      pattern: "GraphRetriever|graph_retriever\\.retrieve"
---

<objective>
Implement graph-aware retrieval that enhances hybrid search with knowledge graph context.

Purpose: Enable the system to answer relationship-based questions ("how does X connect to Y?", "what depends on Z?") by expanding queries through the knowledge graph. This implements KG-05 (graph-aware retrieval for multi-component questions).

Output: GraphRetriever service and enhanced HybridRetriever with dual-channel merging.
</objective>

<execution_context>
@C:\Users\Omer\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Omer\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-knowledge-graph-integration/04-CONTEXT.md
@.planning/phases/04-knowledge-graph-integration/04-RESEARCH.md
@.planning/phases/04-knowledge-graph-integration/04-01-SUMMARY.md
@.planning/phases/04-knowledge-graph-integration/04-02-SUMMARY.md
@backend/app/services/retriever.py
@backend/app/routers/chat.py
@backend/app/services/generator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GraphRetriever service</name>
  <files>backend/app/services/graph/graph_retriever.py</files>
  <action>
    Create GraphRetriever class for graph-based context expansion:

    1. __init__(self, graph_store: GraphStore = None, extractor: EntityExtractor = None):
       - Initialize with GraphStore and EntityExtractor (use defaults if not provided)
       - Store settings.GRAPH_TRAVERSAL_DEPTH for BFS depth limit

    2. async extract_query_entities(self, query: str) -> List[str]:
       - Use EntityExtractor.extract_from_chunk() on the query text
       - Return list of entity names mentioned in query
       - Handle case where no entities found (return empty list)

    3. def is_relationship_query(self, query: str) -> bool:
       - Detect if query is relationship-focused using keyword patterns
       - Keywords: "connect", "depend", "configure", "interface", "relate", "how does X work with Y"
       - Also check for multiple entity mentions (2+ entities = likely relationship query)
       - Return True if relationship-focused (use deeper traversal)

    4. async retrieve_graph_context(
         self,
         query: str,
         user_id: str,
         request_id: str
       ) -> List[dict]:
       - Extract entities from query
       - For each entity (limit to top 3 to avoid explosion):
         - Determine depth: 2 if is_relationship_query(), else 1
         - Call graph_store.get_subgraph(entity, user_id, depth)
         - Convert subgraph to chunk-like dicts for merging
       - Return list of graph-derived context entries

       Format for graph context entry:
       {
           "text": "{entity.name}: {entity.description}",
           "doc_id": entity.doc_id,
           "chunk_id": f"graph-{entity.name}",  # Mark as graph-derived
           "filename": "Knowledge Graph",  # Distinguish from document chunks
           "page_range": "N/A",
           "source": "graph",  # Flag for citation tracking
           "entity_name": entity.name,
           "relationships": [...]  # Connected relationships for context
       }

    5. def format_relationship_context(self, entity: dict, relationships: List[dict]) -> str:
       - Format entity and its relationships as readable text for LLM
       - Include relationship context sentences from graph
       - Example: "GPS Module: Global Positioning System receiver. Depends on: Power Supply (for operation). Connects to: Navigation System (via serial interface)."
  </action>
  <verify>
    python -c "
    import asyncio
    from app.services.graph.graph_retriever import GraphRetriever
    retriever = GraphRetriever()
    # Simple query
    assert not retriever.is_relationship_query('What is GPS?')
    # Relationship query
    assert retriever.is_relationship_query('How does GPS connect to navigation?')
    print('GraphRetriever detection works')
    "
  </verify>
  <done>GraphRetriever extracts query entities and retrieves connected graph context.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate graph retrieval into HybridRetriever</name>
  <files>backend/app/services/retriever.py</files>
  <action>
    Modify HybridRetriever to implement dual-channel retrieval:

    1. Add import:
       from app.services.graph.graph_retriever import GraphRetriever

    2. Update __init__ to initialize GraphRetriever:
       self.graph_retriever = GraphRetriever()

    3. Add config setting for enabling graph retrieval:
       Check if settings.GRAPH_RETRIEVAL_ENABLED exists, default to True

    4. Modify retrieve() method to add graph channel:
       After semantic chunks are retrieved:

       # Channel 2: Graph context (if enabled)
       graph_chunks = []
       if settings.GRAPH_RETRIEVAL_ENABLED:
           try:
               graph_chunks = await self.graph_retriever.retrieve_graph_context(
                   query=query,
                   user_id=user_id,
                   request_id=request_id
               )
               logger.info("graph_retrieval_complete",
                          request_id=request_id,
                          graph_chunk_count=len(graph_chunks))
           except Exception as e:
               logger.warning("graph_retrieval_failed",
                             request_id=request_id,
                             error=str(e))
               # Continue without graph context

       # Merge channels
       merged_chunks = self._merge_channels(semantic_chunks, graph_chunks)

    5. Add _merge_channels(self, semantic: List[dict], graph: List[dict]) -> List[dict]:
       - Priority: semantic chunks first (higher confidence)
       - Deduplicate: if graph entity already covered in semantic chunk text, skip it
       - Add graph chunks that provide NEW entity information
       - Return merged list (semantic + unique graph context)
       - Maintain limit (don't exceed 2x original limit)

    6. Update diagnostics to include graph retrieval stats:
       - graph_entity_count: entities extracted from query
       - graph_context_count: graph chunks added
       - graph_latency_ms: time for graph retrieval
  </action>
  <verify>
    # Requires populated graph
    python -c "
    import asyncio
    from app.services.retriever import HybridRetriever
    retriever = HybridRetriever()
    result = asyncio.run(retriever.retrieve(
        query='How does GPS connect to navigation?',
        user_id='test_user',
        request_id='test123'
    ))
    print(f'Total chunks: {result[\"count\"]}')
    "
  </verify>
  <done>HybridRetriever merges semantic search with graph-derived context for enhanced retrieval.</done>
</task>

<task type="auto">
  <name>Task 3: Update generator to distinguish graph-derived citations</name>
  <files>backend/app/services/generator.py</files>
  <action>
    Modify Generator to handle graph-derived context:

    1. Update context building in generate() method:
       - Check chunk["source"] == "graph" to identify graph-derived context
       - Format graph chunks differently in prompt:
         "[{idx}: Knowledge Graph - {entity_name}]"
       - Include relationship context in the text

    2. Update Citation creation to mark graph-derived citations:
       - Add source field to Citation model if not present (in app/models/chat.py)
       - Set source="graph" for graph-derived citations, source="document" for regular
       - This enables UI to distinguish inferred vs stated information (CONTEXT.md requirement)

    3. Update SYSTEM_PROMPT to handle graph context:
       Add instruction: "When citing knowledge graph information, note that these are system-inferred relationships based on extracted entities. Mark such citations clearly."
  </action>
  <verify>
    # Check Citation model has source field
    python -c "
    from app.models.chat import Citation
    c = Citation(id=1, doc_id='d1', filename='test', page_range='1', snippet='x', source='graph')
    print(f'Citation source: {c.source}')
    "
  </verify>
  <done>Generator distinguishes graph-derived context in prompts and citations.</done>
</task>

</tasks>

<verification>
1. Query entity extraction: Query "What is GPS?" extracts entity "GPS"
2. Relationship detection: "How does X connect to Y?" is detected as relationship query
3. Subgraph expansion: Relationship query triggers depth=2 traversal
4. Dual-channel merge: Retrieved chunks include both semantic and graph-derived entries
5. Graph citation marking: Citations from graph have source="graph"
6. Error resilience: Graph retrieval failure doesn't break hybrid retrieval
</verification>

<success_criteria>
- GraphRetriever.extract_query_entities() correctly identifies entities in questions
- Relationship queries trigger deeper graph traversal (depth=2)
- Simple factual queries use minimal graph expansion (depth=1)
- Merged results include graph context without duplicating semantic chunks
- Graph-derived citations are marked with source="graph" for transparency
- Chat endpoint returns enhanced answers for relationship-based questions
</success_criteria>

<output>
After completion, create `.planning/phases/04-knowledge-graph-integration/04-04-SUMMARY.md`
</output>
